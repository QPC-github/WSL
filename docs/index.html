
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="X-UA-Compatible" content="IE=Edge" />
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    <title>WHLSL documentation</title>
    <link rel="stylesheet" href="static/nature.css" type="text/css" />
    <link rel="stylesheet" href="static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="./" src="static/documentation_options.js"></script>
    <script type="text/javascript" src="static/jquery.js"></script>
    <script type="text/javascript" src="static/underscore.js"></script>
    <script type="text/javascript" src="static/doctools.js"></script>
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
  </head><body>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html#document-index">WHLSL  documentation</a> &#187;</li> 
      </ul>
    </div>  

    <div class="document">
      <div class="documentwrapper">
        <div class="bodywrapper">
          <div class="body" role="main">
            
  <div class="section" id="whlsl-specification">
<h1>WHLSL Specification<a class="headerlink" href="#whlsl-specification" title="Permalink to this headline">¶</a></h1>
<div class="section" id="general">
<h2>General<a class="headerlink" href="#general" title="Permalink to this headline">¶</a></h2>
<p><em>This section is non-normative.</em></p>
<p>A shader passes through a series of compilation steps, eventually ending up
represented as machine code for the specific device the user is running. Any
intermediate forms the source may take throughout this transformation are beyond
the scope of this specification.</p>
<dl class="docutils">
<dt>. Note:: The WebGPU Shading Language is designed to target other high-level shading</dt>
<dd>languages as compilation targets.</dd>
</dl>
<p>WHLSL shaders are used with the WebGPU API. Specific WebGPU API entry points to compile
and manipulate shaders are specified in the WebGPU specification, not this document.
This document describes which programs are well-formed; the exact form of error
reporting is not discussed in this specification.</p>
<p>WHLSL does not support extensions or optional behavior.</p>
<p>Terms in this document such as <em>must</em>, <em>must not</em>, <em>required</em>, <em>shall</em>, <em>shall not</em>,
<em>should</em>, <em>should not</em>, <em>recommended</em>, <em>may</em>, and <em>optional</em> in normative parts of
this document are to be interpreted as described in RFC 2119.</p>
</div>
<div class="section" id="basics">
<h2>Basics<a class="headerlink" href="#basics" title="Permalink to this headline">¶</a></h2>
<p>The WebGPU Shading Language is designed to be as portable as possible; therefore,
implementations must reject any shader which does not strictly adhere to this
specification. Optimizations must not affect the validity of a program.
Implementations must not support functionality beyond the mandated parts of this
specification.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The fact that optimizations must not affect the validity of a program means
errors in dead code must cause a compilation failure. However, optimizations may,
in general, be observable, such as fusing a multiply followed by an add into a
single operation which has higher intermediate precision than the distinct operations.
This means that the same WHLSL program run on different machines, browsers, or operating
systems may might not produce the exact same results bit-for-bit.</p>
</div>
<p>A shader is a compilation unit which includes type definitions and function definitions.</p>
<p>WHLSL is used to describe different types of shaders:</p>
<ol class="arabic simple">
<li>Vertex shaders</li>
<li>Fragment shaders</li>
<li>Compute shaders</li>
</ol>
<p>Each shader type represents software which may execute on a specialized processor. Different
draw calls, different shader types, or different invocations of the same shader, may execute
on independent processors.</p>
<p>A WHLSL string passes through the following stages of processing before it is executed:</p>
<ol class="arabic simple">
<li>Tokenization</li>
<li>Parsing</li>
<li>Validation</li>
</ol>
<p>Once a WHLSL string passes all the validation checks, it is then available to be used in a
draw call or dispatch call. A WHLSL string contains zero or more shaders, and each shader is
of a specific shader type. Compute shaders must only be used for dispatch calls, and vertex
and fragment shaders must only be used in draw calls.</p>
</div>
<div class="section" id="pipelines">
<h2>Pipelines<a class="headerlink" href="#pipelines" title="Permalink to this headline">¶</a></h2>
<p>WebGPU includes two pipelines: the graphics pipeline and the compute pipeline.</p>
<div class="section" id="graphics-pipeline">
<h3>Graphics Pipeline<a class="headerlink" href="#graphics-pipeline" title="Permalink to this headline">¶</a></h3>
<p>The WebGPU graphics pipeline includes five stages, two of which are programmable. The graphics
pipeline is invoked by WebGPU draw calls.</p>
<div class="section" id="input-assembler">
<h4>Input Assembler<a class="headerlink" href="#input-assembler" title="Permalink to this headline">¶</a></h4>
<p>The first stage of the graphics pipeline is the input assembler. This stage is not programmable.
This stage may do a collection of many things, including collecting primitives, determining which
vertices are actually referenced in the draw call, extruding points/lines, expanding adjacency
information into adjacent triangles, and more. As this stage is not programmable, the exact
behavior of this stage is not observable. This stage is configured with the WebGPU API.</p>
</div>
<div class="section" id="vertex-shader">
<h4>Vertex Shader<a class="headerlink" href="#vertex-shader" title="Permalink to this headline">¶</a></h4>
<p>After the vertices relevant to a particular draw call have been determined, they are run through
the programmable vertex shader. A vertex shader is responsible for mapping a single input vertex
to a single output vertex. Multiple vertex shaders may run in parallel; two arbitrary vertices
may be mapped through the vertex shader concurrently or sequentially.</p>
<p>An input vertex may be any assortment of information, arranged into four forms:</p>
<ol class="arabic simple">
<li>Stage-in data. Each invocation of the vertex shader is associated with data from a particular
index in a GPU buffer. The WebGPU API is responsible for describing the association between
which invocation receives which index in which buffer. Stage-in data must only be of scalar,
vector, or matrix type.</li>
<li>Resources. All invocations of the vertex shader may have access to one or more resources.
All invocations share the same resource; therefore, data races may occur between read-write
resources. Resources may be of type buffer, texture, or sampler.</li>
<li>Built-ins. Some information can be made available to the shader automatically (such as the
vertex ID or the instance ID).</li>
<li>Specialization constants. These are scalar variables for which the WebGPU API specifies a value
before the shader may be used.</li>
</ol>
<p>Because vertex shaders may have write-access to resources, they are not “pure” in the functional
sense. The order of execution of multiple invocations of the vertex shader may be observable.
Execution of multiple invocations of the vertex shader may be multiplexed across multiple processing
units at the entire shader level or the instruction level (or any level in between). Therefore,
when using simple loads and stores, load tearing may occur, or any such artifacts. WHLSL authors must
take care to create shaders which are portable. See below for advice on how to accomplish this.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Specific GPU instructions are not within scope of this document; therefore, races may
lead to surprising and interesting results.</p>
</div>
<p>An output vertex may be any assortment of information, arranged into two forms:</p>
<ol class="arabic simple">
<li>A position, in Clip Coordinates, represented by a float4. When a vertex shader emits a position
in Clip Coordinates, the WebGPU runtime will divide this position by its “w” component, resulting
in a position in Normalized Device Coordinates. In Normalized Device Coordinates, the “x” component
represents horizontal distance across the screen (or other output medium), where -1 represents the
left edge and 1 represents the right edge. Similarly, the “y” component represents the vertical
distance between -1 and 1, and the “z” component represents depth, where -1 represents the minimum
depth and 1 represents the maximum depth.</li>
<li>Other information, represented by a collection of scalar values, vector values, and matrix values.</li>
</ol>
</div>
<div class="section" id="rasterizer">
<h4>Rasterizer<a class="headerlink" href="#rasterizer" title="Permalink to this headline">¶</a></h4>
<p>Once the relevant vertex shaders have been run, their positions have been emitted, and those positions
have been transformed into Normalized Device Coordinates, the rasterizer now interpolates the values
of the other information in the output vertex. For a particular primitive, the rasterizer iterates over
all fragments on the interior of the primitive, and computes the barycentric coordinate of that particular
fragment with respect to the vertices of the primitive. It then computes a weighted average of the other
vertex information using the barycentric coordinates as weights. This stage is not programmable.</p>
</div>
<div class="section" id="fragment-shader">
<h4>Fragment Shader<a class="headerlink" href="#fragment-shader" title="Permalink to this headline">¶</a></h4>
<p>After the vertex output information has been interpolated across the face of each vertex, one invocation
of the fragment shader runs for each of these sets of interpolated values. A fragment shader is
responsible for mapping the interpolated result of the vertex shader into a single output fragment (which
is usually a color in the framebuffer, but may be other information such as geometry in a G-buffer or
lighting accumulation in a lighting buffer).</p>
<p>Similar to a vertex shader, a fragment shader input may be any assortment of information, arranged into
four forms:</p>
<ol class="arabic simple">
<li>Interpolated output from the vertex shader. These variables are matched to vertex shader variables
using the routine described below.</li>
<li>Resources. All invocations of the fragment shader may have access to one or more resources.
All invocations share the same resource; therefore, data races may occur between read-write
resources. Resources may be of type buffer, texture, or sampler.</li>
<li>Built-ins. Some information can be made available to the shader automatically (such as the
sample ID or the primitive ID).</li>
<li>Specialization constants. These are scalar variables for which the WebGPU API specifies a value
before the shader may be used.</li>
</ol>
<p>Because vertex shaders may have write-access to resources, they are not “pure” in the functional
sense. The order of execution of multiple invocations of the vertex shader may be observable.
Execution of multiple invocations of the vertex shader may be multiplexed across multiple processing
units at the entire shader level or the instruction level (or any level in between). Therefore,
WHLSL authors must take care to create shaders which are portable. See below for advice on how to
accomplish this.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Specific GPU instructions are not within scope of this document; therefore, races may
lead to surprising and interesting results.</p>
</div>
<p>Because each invocation of the fragment shader is associated with a particuluar fragment with respect
to the geometry of the primitive being drawn, the fragment shader can output into a particular region
into zero or more attachments of the framebuffer. The fragment shader does not choose which region
of the framebuffer its results get outputted into; instead, the fragment shader only gets to choose
which values get outputted into that region.</p>
<p>The destination region of the framebuffer may be a pixel on the screen (if the framebuffer is attached
to a canvas element). It may also be a texel in a texture, or a particular sample or set of samples in
a multisampled texture.</p>
<p>The type of this output data must match the type of the framebuffer attachments being written into.
See below for a rigorous definition of “match.”</p>
</div>
<div class="section" id="output-merger">
<h4>Output Merger<a class="headerlink" href="#output-merger" title="Permalink to this headline">¶</a></h4>
<p>Once the fragment shader outputs a particular value for a fragment, that value must be merged with
whatever value the fragment already happens to hold. For example, the new color may be linearly
blended with the existing framebuffer contents (possibly using the “w” channel of the new color to
determine the weights).</p>
<p>The output merger for a particular fragment is guaranteed to occur in API submission order for all
primitives that overlap that particular fragment.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This is in contrast to the fragment shader stage of the pipeline, which has no such
guarantee.</p>
</div>
</div>
</div>
<div class="section" id="compute-pipeline">
<h3>Compute pipeline<a class="headerlink" href="#compute-pipeline" title="Permalink to this headline">¶</a></h3>
<p>The compute pipeline only has a single stage, and is invoked by WebGPU dispatch calls. The compute
pipeline and the graphics pipeline are thus mutually exclusive; a single WebGPU call will invoke
either the graphics pipeline or the compute pipeline, but not both.</p>
<p>Compute shader invocations are arranged into a two-level hierarchy: invocations are grouped into
blocks, and blocks are grouped into a single grid. Multiple invocations that share a block share
threadgroup variables for both reading and writing.</p>
<p>The WebGPU API describes how many invocations of the compute shader to invoke, as well as how big
the blocks should be within the grid.</p>
<p>The input to a compute shader may be any assortment of information, arranged into three forms:</p>
<ol class="arabic simple">
<li>Resources. All invocations of the compute shader may have access to one or more resources.
All invocations share the same resource; therefore, data races may occur between read-write
resources. Resources may be of type buffer, texture, or sampler.</li>
<li>Built-ins. Some information can be made available to the shader automatically (such as the
invocation ID within the block or the block ID within the grid).</li>
<li>Specialization constants. These are scalar variables for which the WebGPU API specifies a value
before the shader may be used.</li>
</ol>
</div>
<div class="section" id="entry-points">
<h3>Entry Points<a class="headerlink" href="#entry-points" title="Permalink to this headline">¶</a></h3>
<p>All functions in WHLSL are either “entry points” or “non-entry points.” An entry point is a function
that may be associated with a particular programmable stage in a pipeline. Entry points may call
non-entry points, non-entry points may call non-entry points, but entry points may not be called
by any WHLSL function. When execution of a particular shader stage begins, the entry point associated
with that shader stage begins, and when that entry point returns, the associated shader stage ends.</p>
<p>Exactly one WHLSL shader occupies one stage in the WebGPU pipeline at a time. Two shaders
of the same shader type must not be used together in the same draw call or dispatch call.
Every stage of the appropriate WebGPU pipeline must be occupied by a shader in order to
execute a draw call or dispatch call.</p>
<p>All entry points must begin with the keyword “vertex”, “fragment”, or “compute”, and the keyword
describes which pipeline stage that shader is appropriate for. An entry point is only valid for one
type of shader stage.</p>
<p>Built-ins are identified by name. WHLSL does not include annotations for identifying built-ins. If
the return of a shader should be assigned to a built-in, the author should create a struct with
a variable named according to to the built-in, and the shader should return that struct.</p>
<p>Vertex and fragment entry points must transitively never refer to the <code class="docutils literal notranslate"><span class="pre">threadgroup</span></code> memory space.</p>
<div class="section" id="arguments-and-return-types">
<h4>Arguments and Return Types<a class="headerlink" href="#arguments-and-return-types" title="Permalink to this headline">¶</a></h4>
<p>Arguments return types of an entry point are more restricted than arguments to an arbitrary WHLSL function.
They are flattened through structs - that is, each member of any struct appearing in an argument to an entry
point or return type is considered independently, recursively. Arguments to entry points are not
distinguished by position or order.</p>
<p>Multiple members with the same name may appear inside the flattened collection of arguments. However,
if multiple members with the same name appear, the entire variable (type, qualifiers, etc.) must be
identical. Otherwise, the entire program is in error.</p>
<p>The items of the flattened structs can be partitioned into a number of buckets:</p>
<ol class="arabic simple">
<li>Built-in variables. These declaractions use the appropriate built-in semantic from the list below,
and must use the appropriate type for that semantic.</li>
<li>Resources. These must be either the opaque texture types, opaque sampler types, or slices. Slices must
only hold scalars, vectors, matrices, or structs containing any of these types. Nested structs are
allowed. The packing rules for data inside slices are described below. All resources must be in the
<code class="docutils literal notranslate"><span class="pre">device</span></code> or <code class="docutils literal notranslate"><span class="pre">constant</span></code> memory space, and use the appropriate semantic as described below.</li>
<li>Stage-in/out variables. These are variables of scalar, vector, or matrix type. Stage-in variables in
a vertex shader must use the semantic `` : attribute(n)`` where n is a nonnegative integer. Stage-out
variables in a vertex shader and stage-in variables in a fragment shader must also use the semantic
`` : attribute(n)``. Stage-out variables in a vertex shader are matched with stage-in variables in a
fragment shader by semantic. After these stage-in/stage-out varaibles match, their qualified type must
also match. After discovering all these matches, any other left-over variables are simply zero-filled.</li>
<li>Specialization constants. These are scalar variables which must be specified by the WebGPU API before
the shader is allowed to execute. These variables must use the <code class="docutils literal notranslate"><span class="pre">specialized</span></code> semantic.</li>
</ol>
<p>Vertex shaders accept all four buckets as input, and allow only built-in variables and stage-out variables
as output. Fragment shaders accept all four buckets as input, and allow only built-in variables as output.
Compute shaders only accept built-in variables and resources, and do not allow any output.</p>
<p>If an entry-point returns a single built-in or stage-out variable, the semantic for that variable must be
placed between the function signature and the function’s opening <code class="docutils literal notranslate"><span class="pre">{</span></code> character.</p>
<p>Vertex shader stage-out variables and fragment-shader stage-in variables may be qualified with any of the
following qualifiers: <code class="docutils literal notranslate"><span class="pre">nointerpolation</span></code>, <code class="docutils literal notranslate"><span class="pre">noperspective</span></code>, <code class="docutils literal notranslate"><span class="pre">centroid</span></code>, or <code class="docutils literal notranslate"><span class="pre">sample</span></code>. <code class="docutils literal notranslate"><span class="pre">nointerpolation</span></code>
and <code class="docutils literal notranslate"><span class="pre">noperspective</span></code> must not both be specified on the same variable. <code class="docutils literal notranslate"><span class="pre">centroid</span></code> and <code class="docutils literal notranslate"><span class="pre">sample</span></code> must not
both be specified on the same variable. If other variables are qualified with these qualifiers, the qualifiers
are ignored.</p>
<p><code class="docutils literal notranslate"><span class="pre">nointerpolation</span></code> configures the rasterizer to not interpolate the value of this variable across the
geometry. <code class="docutils literal notranslate"><span class="pre">noperspective</span></code> configures the rasterize to not use perspective-correct interpolation,
and instead use simple linear interpolation. <code class="docutils literal notranslate"><span class="pre">centroid</span></code> configures the rasterizer to use a position
in the centroid of all the samples within the geometry, rather than the center of the pixel. <code class="docutils literal notranslate"><span class="pre">sample</span></code>
configures the fragment shader to run multiple times per pixel, with the interpolation point at each
individual sample.</p>
<p>The value used for variables qualified with the <code class="docutils literal notranslate"><span class="pre">nointerpolation</span></code> qualifier is the value produced by
one vertex shader invocation per primitive, known as the “provoking vertex.” When drawing points, the
provoking vertex is the vertex associated with that point (since points only have a single vertex).
When drawing lines, the provoking vertex is the initial vertex (rather than the final vertex). When
drawing triangles, the provoking vertex is also the initial vertex. Strips and fans are not supported
by WHLSL.</p>
<p>When not in the context of arguments or return values of entry points, semantics are ignored.</p>
</div>
</div>
</div>
<div class="section" id="grammar">
<h2>Grammar<a class="headerlink" href="#grammar" title="Permalink to this headline">¶</a></h2>
<div class="section" id="lexical-analysis">
<h3>Lexical analysis<a class="headerlink" href="#lexical-analysis" title="Permalink to this headline">¶</a></h3>
<p>Shaders exist as a Unicode string, and therefore support all the code points
Unicode supports.</p>
<p>WHLSL does not include any digraphs or trigraphs. WHLSL is case-sensitive. It does not include any
escape sequences.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">WHLSL does not include a string type, so escape characters are not present in the
language.</p>
</div>
<p>WHLSL does not include a preprocessor step.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Because there is no processor step, tokens such as ‘#if’ are generally considered
parse errors.</p>
</div>
<p>Before parsing, the text of a WHLSL program is first turned into a list of tokens, removing comments and whitespace along the way.
Tokens are built greedily, in other words each token is as long as possible.
If the program cannot be transformed into a list of tokens by following these rules, the program is invalid and must be rejected.</p>
<p>A token can be either of:</p>
<ul class="simple">
<li>An integer literal</li>
<li>A float literal</li>
<li>Punctuation</li>
<li>A keyword</li>
<li>A normal identifier</li>
<li>An operator name</li>
</ul>
<div class="section" id="literals">
<h4>Literals<a class="headerlink" href="#literals" title="Permalink to this headline">¶</a></h4>
<p>An integer literal can either be decimal or hexadecimal, and either signed or unsigned, giving 4 possibilities.</p>
<ul class="simple">
<li>A signed decimal integer literal starts with an optional <code class="docutils literal notranslate"><span class="pre">-</span></code>, then a number without leading 0 or just the number 0.</li>
<li>An unsigned decimal integer literal starts with a number without leading 0, or just the number 0, then <code class="docutils literal notranslate"><span class="pre">u</span></code>.</li>
<li>A signed hexadecimal integer literal starts with an optional <code class="docutils literal notranslate"><span class="pre">-</span></code>, then the string <code class="docutils literal notranslate"><span class="pre">0x</span></code>, then a non-empty sequence of elements of [0-9a-fA-F] (non-case sensitive, leading 0s are allowed).</li>
<li>An unsigned hexadecimal inter literal starts with the string <code class="docutils literal notranslate"><span class="pre">0x</span></code>, then a non-empty sequence of elements of [0-9a-fA-F] (non-case sensitive, leading 0s are allowed), and finally the character <code class="docutils literal notranslate"><span class="pre">u</span></code>.</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Leading 0s are allowed in hexadecimal integer literals, but not in decimal integer literals except for the 0, -0 and 0u.</p>
</div>
<p>A float literal is made of the following elements in sequence:</p>
<ul class="simple">
<li>an optional <code class="docutils literal notranslate"><span class="pre">-</span></code> character</li>
<li>a sequence of 0 or more digits (in [0-9])</li>
<li>a <code class="docutils literal notranslate"><span class="pre">.</span></code> character</li>
<li>a sequence of 0 or more digits (in [0-9]). This sequence must instead have 1 or more elements, if the last sequence was empty.</li>
<li>optionally a <code class="docutils literal notranslate"><span class="pre">f</span></code> character</li>
</ul>
<p>In regexp form: ‘-‘? ([0-9]+ ‘.’ [0-9]* | [0-9]* ‘.’ [0-9]+) f?</p>
</div>
<div class="section" id="keywords-and-punctuation">
<h4>Keywords and punctuation<a class="headerlink" href="#keywords-and-punctuation" title="Permalink to this headline">¶</a></h4>
<p>The following strings are reserved keywords of the language:</p>
<table border="1" class="docutils">
<colgroup>
<col width="26%" />
<col width="74%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Top level</td>
<td>struct typedef enum operator vertex fragment compute numthreads</td>
</tr>
<tr class="row-even"><td>Control flow</td>
<td>if else switch case default while do for break continue fallthrough return</td>
</tr>
<tr class="row-odd"><td>Literals</td>
<td>null true false</td>
</tr>
<tr class="row-even"><td>Address space</td>
<td>constant device threadgroup thread</td>
</tr>
<tr class="row-odd"><td>Qualifier</td>
<td>nointerpolation noperspective specialized centroid sample</td>
</tr>
<tr class="row-even"><td>‘Semantics’ qualifier</td>
<td>SV_InstanceID SV_VertexID PSIZE SV_Position SV_IsFrontFace SV_SampleIndex
SV_InnerCoverage SV_Target SV_Depth SV_Coverage SV_DispatchThreadId SV_GroupID
SV_GroupIndex SV_GroupThreadID attribute register specialized</td>
</tr>
<tr class="row-odd"><td>Reserved for future extension</td>
<td>protocol auto const static restricted native space uniform</td>
</tr>
</tbody>
</table>
<p><code class="docutils literal notranslate"><span class="pre">null</span></code>, <code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code> are keywords, but they are considered literals in the grammar rules later.</p>
<p>Similarily, the following elements of punctuation are valid tokens:</p>
<table border="1" class="docutils">
<colgroup>
<col width="19%" />
<col width="81%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>Relational operators</td>
<td><code class="docutils literal notranslate"><span class="pre">==</span></code> <code class="docutils literal notranslate"><span class="pre">!=</span></code> <code class="docutils literal notranslate"><span class="pre">&lt;=</span></code> <code class="docutils literal notranslate"><span class="pre">=&gt;</span></code> <code class="docutils literal notranslate"><span class="pre">&lt;</span></code> <code class="docutils literal notranslate"><span class="pre">&gt;</span></code></td>
</tr>
<tr class="row-even"><td>Assignment operators</td>
<td><code class="docutils literal notranslate"><span class="pre">=</span></code> <code class="docutils literal notranslate"><span class="pre">++</span></code> <code class="docutils literal notranslate"><span class="pre">--</span></code> <code class="docutils literal notranslate"><span class="pre">+=</span></code> <code class="docutils literal notranslate"><span class="pre">-=</span></code> <code class="docutils literal notranslate"><span class="pre">*=</span></code> <code class="docutils literal notranslate"><span class="pre">/=</span></code> <code class="docutils literal notranslate"><span class="pre">%=</span></code> <code class="docutils literal notranslate"><span class="pre">^=</span></code> <code class="docutils literal notranslate"><span class="pre">&amp;=</span></code>  <code class="docutils literal notranslate"><span class="pre">|=</span></code> <code class="docutils literal notranslate"><span class="pre">&gt;&gt;=</span></code>  <code class="docutils literal notranslate"><span class="pre">&lt;&lt;=</span></code></td>
</tr>
<tr class="row-odd"><td>Arithmetic operators</td>
<td><code class="docutils literal notranslate"><span class="pre">+</span></code>  <code class="docutils literal notranslate"><span class="pre">-</span></code> <code class="docutils literal notranslate"><span class="pre">*</span></code> <code class="docutils literal notranslate"><span class="pre">/</span></code> <code class="docutils literal notranslate"><span class="pre">%</span></code></td>
</tr>
<tr class="row-even"><td>Logic operators</td>
<td><code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code> <code class="docutils literal notranslate"><span class="pre">||</span></code> <code class="docutils literal notranslate"><span class="pre">&amp;</span></code>  <code class="docutils literal notranslate"><span class="pre">|</span></code>  <code class="docutils literal notranslate"><span class="pre">^</span></code> <code class="docutils literal notranslate"><span class="pre">&gt;&gt;</span></code> <code class="docutils literal notranslate"><span class="pre">&lt;&lt;</span></code> <code class="docutils literal notranslate"><span class="pre">!</span></code> <code class="docutils literal notranslate"><span class="pre">~</span></code></td>
</tr>
<tr class="row-odd"><td>Memory operators</td>
<td><code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> <code class="docutils literal notranslate"><span class="pre">.</span></code> <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> <code class="docutils literal notranslate"><span class="pre">&#64;</span></code></td>
</tr>
<tr class="row-even"><td>Other</td>
<td><code class="docutils literal notranslate"><span class="pre">?</span></code> <code class="docutils literal notranslate"><span class="pre">:</span></code> <code class="docutils literal notranslate"><span class="pre">;</span></code> <code class="docutils literal notranslate"><span class="pre">,</span></code> <code class="docutils literal notranslate"><span class="pre">[</span></code> <code class="docutils literal notranslate"><span class="pre">]</span></code> <code class="docutils literal notranslate"><span class="pre">{</span></code> <code class="docutils literal notranslate"><span class="pre">}</span></code> <code class="docutils literal notranslate"><span class="pre">(</span></code> <code class="docutils literal notranslate"><span class="pre">)</span></code></td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="identifiers">
<h4>Identifiers<a class="headerlink" href="#identifiers" title="Permalink to this headline">¶</a></h4>
<p>An identifier is any sequence of characters or underscores, that does not start by a digit, that is not a single underscore (the single underscore is reserved for future extension), and that is not a reserved keyword.</p>
</div>
<div class="section" id="whitespace-and-comments">
<h4>Whitespace and comments<a class="headerlink" href="#whitespace-and-comments" title="Permalink to this headline">¶</a></h4>
<p>Any of the following characters are considered whitespace, and ignored after this phase: space, tabulation (<code class="docutils literal notranslate"><span class="pre">\t</span></code>), carriage return (<code class="docutils literal notranslate"><span class="pre">\r</span></code>), new line(<code class="docutils literal notranslate"><span class="pre">\n</span></code>).</p>
<p>WHLSL also allows two kinds of comments. These are treated like whitespace (i.e. ignored during parsing).
The first kind is a line comment, that starts with the string <code class="docutils literal notranslate"><span class="pre">//</span></code> and continues until the next end of line character.
The second kind is a multi-line comment, that starts with the string <code class="docutils literal notranslate"><span class="pre">/*</span></code> and ends as soon as the string <code class="docutils literal notranslate"><span class="pre">*/</span></code> is read.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Multi-line comments cannot be nested, as the first <code class="docutils literal notranslate"><span class="pre">*/</span></code> closes the outermost <code class="docutils literal notranslate"><span class="pre">/*</span></code></p>
</div>
</div>
</div>
<div class="section" id="parsing">
<span id="parsing-label"></span><h3>Parsing<a class="headerlink" href="#parsing" title="Permalink to this headline">¶</a></h3>
<p>In this section we will describe the grammar of WHLSL programs, using the usual BNF metalanguage (<a class="reference external" href="https://en.wikipedia.org/wiki/Backus–Naur_form">https://en.wikipedia.org/wiki/Backus–Naur_form</a>).
We use names starting with an upper case letter to refer to lexical tokens defined in the previous section, and names starting with a lower case letter to refer to non-terminals. These are linked (at least in the HTML version of this document).
We use non-bold text surrounded by quotes for text terminals (keywords, punctuation, etc..).</p>
<div class="section" id="top-level-declarations">
<h4>Top-level declarations<a class="headerlink" href="#top-level-declarations" title="Permalink to this headline">¶</a></h4>
<p>A valid compilation unit is made of a sequence of 0 or more top-level declarations.</p>
<pre>
<strong id="grammar-token-topLevelDecl">topLevelDecl</strong> ::=  &quot;;&quot; | <a class="reference internal" href="#grammar-token-typedef"><code class="xref docutils literal notranslate"><span class="pre">typedef</span></code></a> | <a class="reference internal" href="#grammar-token-structDef"><code class="xref docutils literal notranslate"><span class="pre">structDef</span></code></a> | <a class="reference internal" href="#grammar-token-enumDef"><code class="xref docutils literal notranslate"><span class="pre">enumDef</span></code></a> | <a class="reference internal" href="#grammar-token-funcDef"><code class="xref docutils literal notranslate"><span class="pre">funcDef</span></code></a>
</pre>
<div class="admonition-todo admonition" id="index-0">
<p class="first admonition-title">Todo</p>
<p class="last">We may want to also allow variable declarations at the top-level if it can easily be supported by all of our targets. (Myles: We can emulate it an all the targets, but the targets themselves only allow constant variables
at global scope. We should follow suit.)
<a class="reference external" href="https://github.com/gpuweb/WHLSL/issues/310">https://github.com/gpuweb/WHLSL/issues/310</a></p>
</div>
<pre>
<strong id="grammar-token-typedef">typedef</strong> ::=  &quot;typedef&quot; <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> &quot;=&quot; <a class="reference internal" href="#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">type</span></code></a> &quot;;&quot;
</pre>
<pre>
<strong id="grammar-token-structDef">structDef    </strong> ::=  &quot;struct&quot; <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> &quot;{&quot; <a class="reference internal" href="#grammar-token-structElement"><code class="xref docutils literal notranslate"><span class="pre">structElement</span></code></a>* &quot;}&quot;
<strong id="grammar-token-structElement">structElement</strong> ::=  <a class="reference internal" href="#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">type</span></code></a> <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> (&quot;:&quot; <a class="reference internal" href="#grammar-token-semantic"><code class="xref docutils literal notranslate"><span class="pre">semantic</span></code></a>)? &quot;;&quot;
</pre>
<pre>
<strong id="grammar-token-enumDef">enumDef    </strong> ::=  &quot;enum&quot; <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> (&quot;:&quot; <a class="reference internal" href="#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">type</span></code></a>)? &quot;{&quot; <a class="reference internal" href="#grammar-token-enumElement"><code class="xref docutils literal notranslate"><span class="pre">enumElement</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-enumElement"><code class="xref docutils literal notranslate"><span class="pre">enumElement</span></code></a>)* &quot;}&quot;
<strong id="grammar-token-enumElement">enumElement</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> (&quot;=&quot; <a class="reference internal" href="#grammar-token-constexpr"><code class="xref docutils literal notranslate"><span class="pre">constexpr</span></code></a>)?
</pre>
<pre>
<strong id="grammar-token-funcDef">funcDef           </strong> ::=  <a class="reference internal" href="#grammar-token-funcDecl"><code class="xref docutils literal notranslate"><span class="pre">funcDecl</span></code></a> &quot;{&quot; <a class="reference internal" href="#grammar-token-stmt"><code class="xref docutils literal notranslate"><span class="pre">stmt</span></code></a>* &quot;}&quot;
<strong id="grammar-token-funcDecl">funcDecl          </strong> ::=  (<a class="reference internal" href="#grammar-token-entryPointDecl"><code class="xref docutils literal notranslate"><span class="pre">entryPointDecl</span></code></a> | <a class="reference internal" href="#grammar-token-normalFuncDecl"><code class="xref docutils literal notranslate"><span class="pre">normalFuncDecl</span></code></a> | <a class="reference internal" href="#grammar-token-castOperatorDecl"><code class="xref docutils literal notranslate"><span class="pre">castOperatorDecl</span></code></a>) (&quot;:&quot; <a class="reference internal" href="#grammar-token-semantic"><code class="xref docutils literal notranslate"><span class="pre">semantic</span></code></a>)?
<strong id="grammar-token-entryPointDecl">entryPointDecl    </strong> ::=  (&quot;vertex&quot; | &quot;fragment&quot; | &quot;[&quot; <a class="reference internal" href="#grammar-token-numthreadsSemantic"><code class="xref docutils literal notranslate"><span class="pre">numthreadsSemantic</span></code></a> &quot;]&quot; &quot;compute&quot;) <a class="reference internal" href="#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">type</span></code></a> <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> <a class="reference internal" href="#grammar-token-parameters"><code class="xref docutils literal notranslate"><span class="pre">parameters</span></code></a>
<strong id="grammar-token-numthreadsSemantic">numthreadsSemantic</strong> ::=  &quot;numthreads&quot; &quot;(&quot; <code class="xref docutils literal notranslate"><span class="pre">IntLiteral</span></code> &quot;,&quot; <code class="xref docutils literal notranslate"><span class="pre">IntLiteral</span></code> &quot;,&quot; <code class="xref docutils literal notranslate"><span class="pre">IntLiteral</span></code> &quot;)&quot;
<strong id="grammar-token-normalFuncDecl">normalFuncDecl    </strong> ::=  <a class="reference internal" href="#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">type</span></code></a> (<code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> | <a class="reference internal" href="#grammar-token-operatorName"><code class="xref docutils literal notranslate"><span class="pre">operatorName</span></code></a>) <a class="reference internal" href="#grammar-token-parameters"><code class="xref docutils literal notranslate"><span class="pre">parameters</span></code></a>
<strong id="grammar-token-castOperatorDecl">castOperatorDecl  </strong> ::=  &quot;operator&quot; <a class="reference internal" href="#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">type</span></code></a> <a class="reference internal" href="#grammar-token-parameters"><code class="xref docutils literal notranslate"><span class="pre">parameters</span></code></a>
<strong id="grammar-token-parameters">parameters        </strong> ::=  &quot;(&quot; &quot;)&quot; | &quot;(&quot; <a class="reference internal" href="#grammar-token-parameter"><code class="xref docutils literal notranslate"><span class="pre">parameter</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-parameter"><code class="xref docutils literal notranslate"><span class="pre">parameter</span></code></a>)* &quot;)&quot;
<strong id="grammar-token-parameter">parameter         </strong> ::=  <a class="reference internal" href="#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">type</span></code></a> <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> (&quot;:&quot; <a class="reference internal" href="#grammar-token-semantic"><code class="xref docutils literal notranslate"><span class="pre">semantic</span></code></a>)?
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">the return type is put after the “operator” keyword when declaring a cast operator, mostly because it is also the name of the created function.</p>
</div>
<pre>
<strong id="grammar-token-operatorName">operatorName</strong> ::=  &quot;operator&quot; (&quot;&gt;&gt;&quot; | &quot;&lt;&lt;&quot; | &quot;+&quot; | &quot;-&quot; | &quot;*&quot; | &quot;/&quot; | &quot;%&quot; | &quot;&amp;&amp;&quot; | &quot;||&quot; | &quot;&amp;&quot; | &quot;|&quot; | &quot;^&quot; | &quot;&gt;=&quot; | &quot;&lt;=&quot; | &quot;==&quot; | &quot;!=&quot; | &quot;&gt;&quot; | &quot;&lt;&quot; | &quot;++&quot; | &quot;--&quot; | &quot;!&quot; | &quot;~&quot; | &quot;[]&quot; | &quot;[]=&quot; | &quot;&amp;[]&quot; | &quot;.&quot; <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> | &quot;.&quot; <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> &quot;=&quot; | &quot;&amp;.&quot; <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code>)
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We call <code class="docutils literal notranslate"><span class="pre">operator.x</span></code> a getter for x, <code class="docutils literal notranslate"><span class="pre">operator.x=</span></code> a setter for x, and <code class="docutils literal notranslate"><span class="pre">operator&amp;.x</span></code> an address taker for x.</p>
</div>
<pre>
<strong id="grammar-token-semantic">semantic                      </strong> ::=  <a class="reference internal" href="#grammar-token-builtInSemantic"><code class="xref docutils literal notranslate"><span class="pre">builtInSemantic</span></code></a> | <a class="reference internal" href="#grammar-token-stageInOutSemantic"><code class="xref docutils literal notranslate"><span class="pre">stageInOutSemantic</span></code></a> | <a class="reference internal" href="#grammar-token-resourceSemantic"><code class="xref docutils literal notranslate"><span class="pre">resourceSemantic</span></code></a> | <a class="reference internal" href="#grammar-token-specializationConstantSemantic"><code class="xref docutils literal notranslate"><span class="pre">specializationConstantSemantic</span></code></a>
<strong id="grammar-token-builtInSemantic">builtInSemantic               </strong> ::=  &quot;SV_InstanceID&quot; | &quot;SV_VertexID&quot; | &quot;PSIZE&quot; | &quot;SV_Position&quot; | &quot;SV_IsFrontFace&quot; | &quot;SV_SampleIndex&quot; | &quot;SV_InnerCoverage&quot; | &quot;SV_Target&quot; <code class="xref docutils literal notranslate"><span class="pre">IntLiteral</span></code> | &quot;SV_Depth&quot; | &quot;SV_Coverage&quot; | &quot;SV_DispatchThreadID&quot; | &quot;SV_GroupID&quot; | &quot;SV_GroupIndex&quot; | &quot;SV_GroupThreadID&quot;
<strong id="grammar-token-stageInOutSemantic">stageInOutSemantic            </strong> ::=  &quot;attribute&quot; &quot;(&quot; <code class="xref docutils literal notranslate"><span class="pre">IntLiteral</span></code> &quot;)&quot;
<strong id="grammar-token-resourceSemantic">resourceSemantic              </strong> ::=  &quot;register&quot; &quot;(&quot; <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> &quot;)&quot; | &quot;register&quot; &quot;(&quot; <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> &quot;,&quot; <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> &quot;)&quot;
<strong id="grammar-token-specializationConstantSemantic">specializationConstantSemantic</strong> ::=  &quot;specialized&quot;
</pre>
</div>
<div class="section" id="statements">
<h4>Statements<a class="headerlink" href="#statements" title="Permalink to this headline">¶</a></h4>
<pre>
<strong id="grammar-token-stmt">stmt          </strong> ::=  &quot;{&quot; (<a class="reference internal" href="#grammar-token-stmt"><code class="xref docutils literal notranslate"><span class="pre">stmt</span></code></a> | <a class="reference internal" href="#grammar-token-variableDecls"><code class="xref docutils literal notranslate"><span class="pre">variableDecls</span></code></a> &quot;;&quot;)* &quot;}&quot;
                    | <a class="reference internal" href="#grammar-token-compoundStmt"><code class="xref docutils literal notranslate"><span class="pre">compoundStmt</span></code></a>
                    | <a class="reference internal" href="#grammar-token-terminatorStmt"><code class="xref docutils literal notranslate"><span class="pre">terminatorStmt</span></code></a> &quot;;&quot;
                    | <a class="reference internal" href="#grammar-token-maybeEffectfulExpr"><code class="xref docutils literal notranslate"><span class="pre">maybeEffectfulExpr</span></code></a> &quot;;&quot;
<strong id="grammar-token-compoundStmt">compoundStmt  </strong> ::=  <a class="reference internal" href="#grammar-token-ifStmt"><code class="xref docutils literal notranslate"><span class="pre">ifStmt</span></code></a> | <a class="reference internal" href="#grammar-token-ifElseStmt"><code class="xref docutils literal notranslate"><span class="pre">ifElseStmt</span></code></a> | <a class="reference internal" href="#grammar-token-whileStmt"><code class="xref docutils literal notranslate"><span class="pre">whileStmt</span></code></a> | <a class="reference internal" href="#grammar-token-doWhileStmt"><code class="xref docutils literal notranslate"><span class="pre">doWhileStmt</span></code></a> | <a class="reference internal" href="#grammar-token-forStmt"><code class="xref docutils literal notranslate"><span class="pre">forStmt</span></code></a> | <a class="reference internal" href="#grammar-token-switchStmt"><code class="xref docutils literal notranslate"><span class="pre">switchStmt</span></code></a>
<strong id="grammar-token-terminatorStmt">terminatorStmt</strong> ::=  &quot;break&quot; | &quot;continue&quot; | &quot;fallthrough&quot; | &quot;return&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>?
</pre>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">fallthrough</span></code> statement is used at the end of switch cases to fallthrough to the next case.
It is not valid to have it anywhere else, or to have a switch case where control-flow reaches the end without a fallthrough (see section <a class="reference internal" href="#typing-statements-label"><span class="std std-ref">Typing statements</span></a>).</p>
</div>
<pre>
<strong id="grammar-token-ifStmt">ifStmt    </strong> ::=  &quot;if&quot; &quot;(&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;)&quot; <a class="reference internal" href="#grammar-token-stmt"><code class="xref docutils literal notranslate"><span class="pre">stmt</span></code></a>
<strong id="grammar-token-ifElseStmt">ifElseStmt</strong> ::=  &quot;if&quot; &quot;(&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;)&quot; <a class="reference internal" href="#grammar-token-stmt"><code class="xref docutils literal notranslate"><span class="pre">stmt</span></code></a> &quot;else&quot; <a class="reference internal" href="#grammar-token-stmt"><code class="xref docutils literal notranslate"><span class="pre">stmt</span></code></a>
</pre>
<p>The first of these two productions is merely syntactic sugar for the second:</p>
<div class="math">
<p><img src="images/math/4abb304b7917a87efa63560c8c47c9e05d7abc09.png" alt="\textbf{if}(e) \,s \leadsto \textbf{if}(e) \,s\, \textbf{else} \,\{\}"/></p>
</div><pre>
<strong id="grammar-token-whileStmt">whileStmt  </strong> ::=  &quot;while&quot; &quot;(&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;)&quot; <a class="reference internal" href="#grammar-token-stmt"><code class="xref docutils literal notranslate"><span class="pre">stmt</span></code></a>
<strong id="grammar-token-forStmt">forStmt    </strong> ::=  &quot;for&quot; &quot;(&quot; (<a class="reference internal" href="#grammar-token-maybeEffectfulExpr"><code class="xref docutils literal notranslate"><span class="pre">maybeEffectfulExpr</span></code></a> | <a class="reference internal" href="#grammar-token-variableDecls"><code class="xref docutils literal notranslate"><span class="pre">variableDecls</span></code></a>) &quot;;&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>? &quot;;&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a>? &quot;)&quot; <a class="reference internal" href="#grammar-token-stmt"><code class="xref docutils literal notranslate"><span class="pre">stmt</span></code></a>
<strong id="grammar-token-doWhileStmt">doWhileStmt</strong> ::=  &quot;do&quot; <a class="reference internal" href="#grammar-token-stmt"><code class="xref docutils literal notranslate"><span class="pre">stmt</span></code></a> &quot;while&quot; &quot;(&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;)&quot; &quot;;&quot;
</pre>
<p>Similarily, we desugar all while loops into do while loops.</p>
<div class="math">
<p><img src="images/math/a4c3abac4fbfc55be66416558e7312c810fdd439.png" alt="\textbf{while} (e)\, s \leadsto \textbf{if} (e) \textbf{do}\, s\, \textbf{while}(e)"/></p>
</div><p>We also partly desugar for loops:</p>
<ol class="arabic simple">
<li>If the second element of the for is empty we replace it by “true”.</li>
<li>If the third element of the for is empty we replace it by “null”. (any effect-free expression would work as well).</li>
<li>If the first element of the for is not empty, we hoist it out of the loop, into a newly created block that includes the loop:</li>
</ol>
<div class="math">
<p><img src="images/math/27be790d1a5fd0774f6b666c0d1eaf345526fea7.png" alt="\textbf{for} (X_{pre} ; e_{cond} ; e_{iter}) \, s \leadsto \{ X_{pre} ; \textbf{for} ( ; e_{cond} ; e_{iter}) \, s \}"/></p>
</div><pre>
<strong id="grammar-token-switchStmt">switchStmt</strong> ::=  &quot;switch&quot; &quot;(&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;)&quot; &quot;{&quot; <a class="reference internal" href="#grammar-token-switchCase"><code class="xref docutils literal notranslate"><span class="pre">switchCase</span></code></a>* &quot;}&quot;
<strong id="grammar-token-switchCase">switchCase</strong> ::=  (&quot;case&quot; <a class="reference internal" href="#grammar-token-constexpr"><code class="xref docutils literal notranslate"><span class="pre">constexpr</span></code></a> | &quot;default&quot;) &quot;:&quot; <a class="reference internal" href="#grammar-token-stmt"><code class="xref docutils literal notranslate"><span class="pre">stmt</span></code></a>*
</pre>
<pre>
<strong id="grammar-token-variableDecls">variableDecls</strong> ::=  <a class="reference internal" href="#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">type</span></code></a> <a class="reference internal" href="#grammar-token-variableDecl"><code class="xref docutils literal notranslate"><span class="pre">variableDecl</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-variableDecl"><code class="xref docutils literal notranslate"><span class="pre">variableDecl</span></code></a>)*
<strong id="grammar-token-variableDecl">variableDecl </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> (&quot;=&quot; <a class="reference internal" href="#grammar-token-ternaryConditional"><code class="xref docutils literal notranslate"><span class="pre">ternaryConditional</span></code></a>)?
</pre>
<p>Complex variable declarations are also mere syntactic sugar.
Several variable declarations separated by commas are the same as separating them with semicolons and repeating the type for each one.
This transformation can always be done because variable declarations are only allowed inside blocks (and for loops, but these get desugared into a block, see above).</p>
</div>
<div class="section" id="types">
<h4>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h4>
<pre>
<strong id="grammar-token-type">type                    </strong> ::=  <a class="reference internal" href="#grammar-token-addressSpace"><code class="xref docutils literal notranslate"><span class="pre">addressSpace</span></code></a> <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> <a class="reference internal" href="#grammar-token-typeArguments"><code class="xref docutils literal notranslate"><span class="pre">typeArguments</span></code></a> <a class="reference internal" href="#grammar-token-typeSuffixAbbreviated"><code class="xref docutils literal notranslate"><span class="pre">typeSuffixAbbreviated</span></code></a>+
                              | <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> <a class="reference internal" href="#grammar-token-typeArguments"><code class="xref docutils literal notranslate"><span class="pre">typeArguments</span></code></a> <a class="reference internal" href="#grammar-token-typeSuffixNonAbbreviated"><code class="xref docutils literal notranslate"><span class="pre">typeSuffixNonAbbreviated</span></code></a>*
<strong id="grammar-token-addressSpace">addressSpace            </strong> ::=  &quot;constant&quot; | &quot;device&quot; | &quot;threadgroup&quot; | &quot;thread&quot;
<strong id="grammar-token-typeSuffixAbbreviated">typeSuffixAbbreviated   </strong> ::=  &quot;*&quot; | &quot;[&quot; &quot;]&quot; | &quot;[&quot; <code class="xref docutils literal notranslate"><span class="pre">IntLiteral</span></code> &quot;]&quot;
<strong id="grammar-token-typeSuffixNonAbbreviated">typeSuffixNonAbbreviated</strong> ::=  &quot;*&quot; <a class="reference internal" href="#grammar-token-addressSpace"><code class="xref docutils literal notranslate"><span class="pre">addressSpace</span></code></a> | &quot;[&quot; &quot;]&quot; <a class="reference internal" href="#grammar-token-addressSpace"><code class="xref docutils literal notranslate"><span class="pre">addressSpace</span></code></a> | &quot;[&quot; <code class="xref docutils literal notranslate"><span class="pre">IntLiteral</span></code> &quot;]&quot;
</pre>
<p>Putting the address space before the identifier is just syntactic sugar for having that same address space applied to all type suffixes.
<code class="docutils literal notranslate"><span class="pre">thread</span> <span class="pre">int</span> <span class="pre">*[]*[42]</span></code> is for example the same as <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">*thread</span> <span class="pre">[]thread</span> <span class="pre">*thread</span> <span class="pre">[42]</span></code>.</p>
<pre>
<strong id="grammar-token-typeArguments">typeArguments</strong> ::=  &quot;&lt;&quot; (<a class="reference internal" href="#grammar-token-typeArgument"><code class="xref docutils literal notranslate"><span class="pre">typeArgument</span></code></a> &quot;,&quot;)* <a class="reference internal" href="#grammar-token-addressSpace"><code class="xref docutils literal notranslate"><span class="pre">addressSpace</span></code></a>? <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> &quot;&lt;&quot;
                   (<a class="reference internal" href="#grammar-token-typeArgument"><code class="xref docutils literal notranslate"><span class="pre">typeArgument</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-typeArgument"><code class="xref docutils literal notranslate"><span class="pre">typeArgument</span></code></a>)*)? &quot;&gt;&gt;&quot;
                   | &quot;&lt;&quot; (<a class="reference internal" href="#grammar-token-typeArgument"><code class="xref docutils literal notranslate"><span class="pre">typeArgument</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-typeArgument"><code class="xref docutils literal notranslate"><span class="pre">typeArgument</span></code></a>)* &quot;&gt;&quot;
                   | (&quot;&lt;&quot; &quot;&gt;&quot;)?
<strong id="grammar-token-typeArgument">typeArgument </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">constepxr</span></code> | <a class="reference internal" href="#grammar-token-type"><code class="xref docutils literal notranslate"><span class="pre">type</span></code></a>
</pre>
<p>The first production rule for typeArguments is a way to say that <cite>&gt;&gt;</cite> can be parsed as two <cite>&gt;</cite> closing delimiters, in the case of nested typeArguments.</p>
</div>
<div class="section" id="expressions">
<h4>Expressions<a class="headerlink" href="#expressions" title="Permalink to this headline">¶</a></h4>
<p>WHLSL accepts three different kinds of expressions, in different places in the grammar.</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">expr</span></code> is the most generic, and includes all expressions.</li>
<li><code class="docutils literal notranslate"><span class="pre">maybeEffectfulExpr</span></code> is used in places where a variable declaration would also be allowed. It forbids some expressions that are clearly effect-free, such as <code class="docutils literal notranslate"><span class="pre">x*y</span></code> or <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;</span> <span class="pre">y</span></code>.
As the name indicates, it may be empty. In that case it is equivalent to “null” (any other effect-free expression would be fine, as the result of such an expression is always discarded).</li>
<li><code class="docutils literal notranslate"><span class="pre">constexpr</span></code> is limited to literals and the elements of an enum. It is used in switch cases, and in type arguments.</li>
</ul>
<pre>
<strong id="grammar-token-expr">expr              </strong> ::=  (<a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;,&quot;)? <a class="reference internal" href="#grammar-token-ternaryConditional"><code class="xref docutils literal notranslate"><span class="pre">ternaryConditional</span></code></a>
<strong id="grammar-token-ternaryConditional">ternaryConditional</strong> ::=  <a class="reference internal" href="#grammar-token-exprLogicalOr"><code class="xref docutils literal notranslate"><span class="pre">exprLogicalOr</span></code></a> &quot;?&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;:&quot; <a class="reference internal" href="#grammar-token-ternaryConditional"><code class="xref docutils literal notranslate"><span class="pre">ternaryConditional</span></code></a>
                        | <a class="reference internal" href="#grammar-token-exprPrefix"><code class="xref docutils literal notranslate"><span class="pre">exprPrefix</span></code></a> <a class="reference internal" href="#grammar-token-assignOperator"><code class="xref docutils literal notranslate"><span class="pre">assignOperator</span></code></a> <a class="reference internal" href="#grammar-token-ternaryConditional"><code class="xref docutils literal notranslate"><span class="pre">ternaryConditional</span></code></a>
                        | <a class="reference internal" href="#grammar-token-exprLogicalOr"><code class="xref docutils literal notranslate"><span class="pre">exprLogicalOr</span></code></a>
<strong id="grammar-token-assignOperator">assignOperator    </strong> ::=  &quot;=&quot; | &quot;+=&quot; | &quot;-=&quot; | &quot;*=&quot; | &quot;/=&quot; | &quot;%=&quot; | &quot;&amp;=&quot; | &quot;|=&quot; | &quot;^=&quot; | &quot;&gt;&gt;=&quot; | &quot;&lt;&lt;=&quot;
<strong id="grammar-token-exprLogicalOr">exprLogicalOr     </strong> ::=  (<a class="reference internal" href="#grammar-token-exprLogicalOr"><code class="xref docutils literal notranslate"><span class="pre">exprLogicalOr</span></code></a> &quot;||&quot;)? <a class="reference internal" href="#grammar-token-exprLogicalAnd"><code class="xref docutils literal notranslate"><span class="pre">exprLogicalAnd</span></code></a>
<strong id="grammar-token-exprLogicalAnd">exprLogicalAnd    </strong> ::=  (<a class="reference internal" href="#grammar-token-exprLogicalAnd"><code class="xref docutils literal notranslate"><span class="pre">exprLogicalAnd</span></code></a> &quot;&amp;&amp;&quot;)? <a class="reference internal" href="#grammar-token-exprBitwiseOr"><code class="xref docutils literal notranslate"><span class="pre">exprBitwiseOr</span></code></a>
<strong id="grammar-token-exprBitwiseOr">exprBitwiseOr     </strong> ::=  (<a class="reference internal" href="#grammar-token-exprBitwiseOr"><code class="xref docutils literal notranslate"><span class="pre">exprBitwiseOr</span></code></a> &quot;|&quot;)? <a class="reference internal" href="#grammar-token-exprBitwiseXor"><code class="xref docutils literal notranslate"><span class="pre">exprBitwiseXor</span></code></a>
<strong id="grammar-token-exprBitwiseXor">exprBitwiseXor    </strong> ::=  (<a class="reference internal" href="#grammar-token-exprBitwiseXor"><code class="xref docutils literal notranslate"><span class="pre">exprBitwiseXor</span></code></a> &quot;^&quot;)? <a class="reference internal" href="#grammar-token-exprBitwiseAnd"><code class="xref docutils literal notranslate"><span class="pre">exprBitwiseAnd</span></code></a>
<strong id="grammar-token-exprBitwiseAnd">exprBitwiseAnd    </strong> ::=  (<a class="reference internal" href="#grammar-token-exprBitwiseAnd"><code class="xref docutils literal notranslate"><span class="pre">exprBitwiseAnd</span></code></a> &quot;&amp;&quot;)? <a class="reference internal" href="#grammar-token-exprRelational"><code class="xref docutils literal notranslate"><span class="pre">exprRelational</span></code></a>
<strong id="grammar-token-exprRelational">exprRelational    </strong> ::=  <a class="reference internal" href="#grammar-token-exprShift"><code class="xref docutils literal notranslate"><span class="pre">exprShift</span></code></a> (<a class="reference internal" href="#grammar-token-relationalBinop"><code class="xref docutils literal notranslate"><span class="pre">relationalBinop</span></code></a> <a class="reference internal" href="#grammar-token-exprShift"><code class="xref docutils literal notranslate"><span class="pre">exprShift</span></code></a>)?
<strong id="grammar-token-relationalBinop">relationalBinop   </strong> ::=  &quot;&lt;&quot; | &quot;&gt;&quot; | &quot;&lt;=&quot; | &quot;&gt;=&quot; | &quot;==&quot; | &quot;!=&quot;
<strong id="grammar-token-exprShift">exprShift         </strong> ::=  (<a class="reference internal" href="#grammar-token-exprShift"><code class="xref docutils literal notranslate"><span class="pre">exprShift</span></code></a> (&quot;&lt;&lt;&quot; | &quot;&gt;&gt;&quot;))? <a class="reference internal" href="#grammar-token-exprAdd"><code class="xref docutils literal notranslate"><span class="pre">exprAdd</span></code></a>
<strong id="grammar-token-exprAdd">exprAdd           </strong> ::=  (<code class="xref docutils literal notranslate"><span class="pre">exprMult</span></code> (&quot;*&quot; | &quot;/&quot; | &quot;%&quot;))? <a class="reference internal" href="#grammar-token-exprPrefix"><code class="xref docutils literal notranslate"><span class="pre">exprPrefix</span></code></a>
<strong id="grammar-token-exprPrefix">exprPrefix        </strong> ::=  <a class="reference internal" href="#grammar-token-prefixOp"><code class="xref docutils literal notranslate"><span class="pre">prefixOp</span></code></a> <a class="reference internal" href="#grammar-token-exprPrefix"><code class="xref docutils literal notranslate"><span class="pre">exprPrefix</span></code></a> | <a class="reference internal" href="#grammar-token-exprSuffix"><code class="xref docutils literal notranslate"><span class="pre">exprSuffix</span></code></a>
<strong id="grammar-token-prefixOp">prefixOp          </strong> ::=  &quot;++&quot; | &quot;--&quot; | &quot;+&quot; | &quot;-&quot; | &quot;~&quot; | &quot;!&quot; | &quot;*&quot; | &quot;&amp;&quot; | &quot;&#64;&quot;
<strong id="grammar-token-exprSuffix">exprSuffix        </strong> ::=  <a class="reference internal" href="#grammar-token-callExpression"><code class="xref docutils literal notranslate"><span class="pre">callExpression</span></code></a> <a class="reference internal" href="#grammar-token-limitedSuffixOp"><code class="xref docutils literal notranslate"><span class="pre">limitedSuffixOp</span></code></a>*
                        | <a class="reference internal" href="#grammar-token-term"><code class="xref docutils literal notranslate"><span class="pre">term</span></code></a> (<a class="reference internal" href="#grammar-token-limitedSuffixOp"><code class="xref docutils literal notranslate"><span class="pre">limitedSuffixOp</span></code></a> | &quot;++&quot; | &quot;--&quot;)*
<strong id="grammar-token-limitedSuffixOp">limitedSuffixOp   </strong> ::=  &quot;.&quot; <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> | &quot;-&gt;&quot; <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> | &quot;[&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;]&quot;
<strong id="grammar-token-callExpression">callExpression    </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> &quot;(&quot; (<a class="reference internal" href="#grammar-token-ternaryConditional"><code class="xref docutils literal notranslate"><span class="pre">ternaryConditional</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-ternaryConditional"><code class="xref docutils literal notranslate"><span class="pre">ternaryConditional</span></code></a>)*)? &quot;)&quot;
<strong id="grammar-token-term">term              </strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">Literal</span></code> | <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> | &quot;(&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;)&quot;
</pre>
<p>WHLSL matches the precedence and associativity of operators from C++, with one exception: relational operators are non-associative,
so that they cannot be chained. Chaining them has sufficiently surprising results that it is not a clear
reduction in usability, and it should make it a lot easier to extend the syntax in the future to accept
generics.</p>
<p>The prefix form of increment and decrement (<code class="docutils literal notranslate"><span class="pre">++e</span></code> and <code class="docutils literal notranslate"><span class="pre">--e</span></code>) are syntactic sugar for <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">+=</span> <span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">e</span> <span class="pre">-=</span> <span class="pre">1</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">-&gt;</span> <span class="pre">y</span></code> is purely syntactic sugar for <code class="docutils literal notranslate"><span class="pre">(*x).y</span></code>, so we will ignore the <code class="docutils literal notranslate"><span class="pre">-&gt;</span></code> operator in the rest of this specification.</p>
<pre>
<strong id="grammar-token-maybeEffectfulExpr">maybeEffectfulExpr</strong> ::=  (<a class="reference internal" href="#grammar-token-effAssignment"><code class="xref docutils literal notranslate"><span class="pre">effAssignment</span></code></a> (&quot;,&quot; <a class="reference internal" href="#grammar-token-effAssignment"><code class="xref docutils literal notranslate"><span class="pre">effAssignment</span></code></a>)*)?
<strong id="grammar-token-effAssignment">effAssignment     </strong> ::=  <a class="reference internal" href="#grammar-token-exprPrefix"><code class="xref docutils literal notranslate"><span class="pre">exprPrefix</span></code></a> <a class="reference internal" href="#grammar-token-assignOperator"><code class="xref docutils literal notranslate"><span class="pre">assignOperator</span></code></a> <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> | <a class="reference internal" href="#grammar-token-effPrefix"><code class="xref docutils literal notranslate"><span class="pre">effPrefix</span></code></a>
<strong id="grammar-token-effPrefix">effPrefix         </strong> ::=  (&quot;++&quot; | &quot;--&quot;) <a class="reference internal" href="#grammar-token-exprPrefix"><code class="xref docutils literal notranslate"><span class="pre">exprPrefix</span></code></a> | <a class="reference internal" href="#grammar-token-effSuffix"><code class="xref docutils literal notranslate"><span class="pre">effSuffix</span></code></a>
<strong id="grammar-token-effSuffix">effSuffix         </strong> ::=  <a class="reference internal" href="#grammar-token-exprSuffix"><code class="xref docutils literal notranslate"><span class="pre">exprSuffix</span></code></a> (&quot;++&quot; | &quot;--&quot;) | <a class="reference internal" href="#grammar-token-callExpression"><code class="xref docutils literal notranslate"><span class="pre">callExpression</span></code></a> | &quot;(&quot; <a class="reference internal" href="#grammar-token-expr"><code class="xref docutils literal notranslate"><span class="pre">expr</span></code></a> &quot;)&quot;
</pre>
<p>The structure of maybeEffectfulExpr roughly match the structure of normal expressions, just with normally effect-free operators left off.</p>
<p>If the programmer still wants to use them in such a position (for example due to having overloaded an operator with an effectful operation),
it can be done just by wrapping the expression in parentheses (see the last alternative for effSuffix).</p>
<pre>
<strong id="grammar-token-constexpr">constexpr</strong> ::=  <code class="xref docutils literal notranslate"><span class="pre">Literal</span></code> | <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code> &quot;.&quot; <code class="xref docutils literal notranslate"><span class="pre">Identifier</span></code>
</pre>
</div>
</div>
</div>
<div class="section" id="validation">
<h2>Validation<a class="headerlink" href="#validation" title="Permalink to this headline">¶</a></h2>
<p>In this section we describe how to determine if a program is valid or not.
If a program is invalid, a compliant implementation must reject it with an appropriate error message, and not attempt to execute it.
If a program is valid, we describe its semantics later in this document.</p>
<p>Validation includes all of typing. If a program is valid, it is also annotated with typing information used by the execution semantics later
(for example, accesses to fixed-size arrays are annotated with the size for the bounds-check).</p>
<p>The validation rules are presented in several steps:</p>
<ul class="simple">
<li>First we explain how the typing environment is built from the top-level declarations (<a class="reference internal" href="#global-typing-environment-label"><span class="std std-ref">Building the global typing environment</span></a>)</li>
<li>Then we provide global validation rules, including checking the absence of recursion (<a class="reference internal" href="#global-validation-label"><span class="std std-ref">Other validation steps</span></a>)</li>
<li>Finally we provide the typing rules (<a class="reference internal" href="#typing-label"><span class="std std-ref">Typing of functions</span></a>)</li>
</ul>
<div class="section" id="building-the-global-typing-environment">
<span id="global-typing-environment-label"></span><h3>Building the global typing environment<a class="headerlink" href="#building-the-global-typing-environment" title="Permalink to this headline">¶</a></h3>
<p>In this first step all top-level declarations are gathered into a global environment.
More precisely they are gathered in three different mappings:</p>
<ul class="simple">
<li>A mapping from identifiers to types (typedefs, enums and structs)</li>
<li>A mapping from identifiers to declarations of global (constant) variables</li>
<li>A mapping from identifiers to sets of function declarations.</li>
</ul>
<p>A type for the purpose of this mapping is either an enum characterized by a set of values, or it is a typedef characterized by its equivalent type, or it is a struct characterized by the types of its elements.
A variable declaration for the purpose of this mapping is characterized by its type.
A function declaration for the purpose of this mapping is characterised by a tuple of the return type, the number and types of the parameters, and the body of the function.</p>
<p>This environment is initialized with the types and function declarations from the standard library, see <a class="reference internal" href="#standard-library-label"><span class="std std-ref">Standard library</span></a>.</p>
<p>For each top-level declaration:</p>
<ol class="arabic">
<li><p class="first">If it is a variable declaration</p>
<ol class="arabic simple">
<li>If there is already a variable of the same name in the environment, the program is invalid</li>
<li>Add it to the mapping with a type Left-value of its declared type in the Constant address space (see <a class="reference internal" href="#typing-expressions-label"><span class="std std-ref">Typing expressions</span></a> for details on types of values)</li>
</ol>
</li>
<li><p class="first">If it is a typedef</p>
<ol class="arabic simple">
<li>If there is already a type of the same name in the environment, the program is invalid</li>
<li>Add it to the mapping, as a new type, associated to its definition</li>
</ol>
</li>
<li><p class="first">If it is a structure</p>
<ol class="arabic simple">
<li>If there is already a type of the same name in the environment, the program is invalid</li>
<li>If two or more fields of the struct have the same name, the program is invalid</li>
<li>Add the struct to the environment as a new type.</li>
<li><dl class="first docutils">
<dt>For each field of the struct, add to the environment a mapping from the name <code class="docutils literal notranslate"><span class="pre">operator&amp;.field=</span></code> (where <code class="docutils literal notranslate"><span class="pre">field</span></code> is replaced by the name of the field) to 4 function declarations with one argument,</dt>
<dd>whose return type is a pointer to the type of the field, and whose argument type is a pointer to the struct itself. There is one such function declaration for each
address space, that address space is used both by the pointer argument and by the return type</dd>
</dl>
</li>
</ol>
</li>
<li><p class="first">If it is an enum</p>
<ol class="arabic">
<li><p class="first">If there is already a type of the same name in the environment, the program is invalid</p>
</li>
<li><p class="first">If the enum has an explicit base type, and it is not one of <code class="docutils literal notranslate"><span class="pre">uint</span></code> or <code class="docutils literal notranslate"><span class="pre">int</span></code> then the program is invalid</p>
</li>
<li><p class="first">If the enum does not have an explicit base type, its base type is <code class="docutils literal notranslate"><span class="pre">int</span></code></p>
</li>
<li><p class="first">A value is associated to each element of the enum, by iterating over them in source order:</p>
<blockquote>
<div><ol class="arabic simple">
<li>If it has an explicit value, then this is its value</li>
<li>Else if it is the first element of the enum, its value is 0</li>
<li>Else its value is the value of the precedent element increased by one.</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">If no element of the enum has the value 0, the program is invalid</p>
</li>
<li><p class="first">If two or more element of the enum have the same value, the program is invalid</p>
</li>
<li><p class="first">If one or more element of the enum have a value that is not representable in the base type of the enum, the program is invalid</p>
</li>
<li><p class="first">Add the enum to the environment as a new type, associated with the set of the values of its elements</p>
</li>
<li><p class="first">For each element of the enum, add a mapping to the variables mapping, from <code class="docutils literal notranslate"><span class="pre">EnumName.ElementName</span></code> (with <code class="docutils literal notranslate"><span class="pre">EnumName</span></code> and <code class="docutils literal notranslate"><span class="pre">ElementName</span></code> replaced) to the enum type</p>
</li>
</ol>
</li>
<li><p class="first">If it is a function declaration</p>
<ol class="arabic">
<li><p class="first">If the name of the function is <code class="docutils literal notranslate"><span class="pre">operator.field</span></code> for some name <code class="docutils literal notranslate"><span class="pre">field</span></code></p>
<blockquote>
<div><ol class="arabic simple">
<li>It must have a single argument</li>
<li>That argument must not be a pointer, array reference or array</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else if the name of the function is <code class="docutils literal notranslate"><span class="pre">operator.field=</span></code> for some name <code class="docutils literal notranslate"><span class="pre">field</span></code></p>
<blockquote>
<div><ol class="arabic simple">
<li>It must have exactly two arguments</li>
<li>Its first argument must not be a pointer, array reference or array</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else if the name of the function is <code class="docutils literal notranslate"><span class="pre">operator&amp;.field</span></code> for some name <code class="docutils literal notranslate"><span class="pre">field</span></code></p>
<blockquote>
<div><ol class="arabic simple">
<li>It must have exactly one argument</li>
<li>Its return type must be a pointer type</li>
<li>Its argument must be a pointer type</li>
<li>Both its return type and its argument type must be in the same address space</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else if the name of the function is <code class="docutils literal notranslate"><span class="pre">operator[]</span></code></p>
<blockquote>
<div><ol class="arabic simple">
<li>It must have exactly two argument</li>
<li>Its first argument must not be a pointer, array reference, or array.</li>
<li>Its second argument must be one of <code class="docutils literal notranslate"><span class="pre">uint</span></code> or <code class="docutils literal notranslate"><span class="pre">int</span></code></li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else if the name of the function is <code class="docutils literal notranslate"><span class="pre">operator[]=</span></code></p>
<blockquote>
<div><ol class="arabic simple">
<li>It must have exactly three arguments</li>
<li>Its first argument must not be a pointer, array reference, or array</li>
<li>Its second argument must be one of <code class="docutils literal notranslate"><span class="pre">uint</span></code> or <code class="docutils literal notranslate"><span class="pre">int</span></code></li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else if the name of the function is <code class="docutils literal notranslate"><span class="pre">operator&amp;[]</span></code></p>
<blockquote>
<div><ol class="arabic simple">
<li>It must have exactly two arguments</li>
<li>Its return type must be a pointer type</li>
<li>Its first argument must be a pointer type</li>
<li>The type pointed at by this pointer cannot be a pointer, array reference, or array.</li>
<li>Both its return type and its first argument type must be in the same address space</li>
<li>Its second argument must be one of <code class="docutils literal notranslate"><span class="pre">uint</span></code> or <code class="docutils literal notranslate"><span class="pre">int</span></code></li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else if the name of the function is <code class="docutils literal notranslate"><span class="pre">operator++</span></code> or <code class="docutils literal notranslate"><span class="pre">operator--</span></code></p>
<blockquote>
<div><ol class="arabic simple">
<li>It must have exactly one argument</li>
<li>Its argument type and its return type must be the same</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else if the name of the function is <code class="docutils literal notranslate"><span class="pre">operator+</span></code> or <code class="docutils literal notranslate"><span class="pre">operator-</span></code>, it must have one or two arguments</p>
</li>
<li><p class="first">Else if the name of the function is <code class="docutils literal notranslate"><span class="pre">operator*</span></code>, <code class="docutils literal notranslate"><span class="pre">operator/</span></code>, <code class="docutils literal notranslate"><span class="pre">operator%</span></code>, <code class="docutils literal notranslate"><span class="pre">operator&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">operator|</span></code>, <code class="docutils literal notranslate"><span class="pre">operator^</span></code>, <code class="docutils literal notranslate"><span class="pre">operator&lt;&lt;</span></code> or <code class="docutils literal notranslate"><span class="pre">operator&gt;&gt;</span></code>, it must have exactly two arguments</p>
</li>
<li><p class="first">Else if the name of the function is <code class="docutils literal notranslate"><span class="pre">operator~</span></code>, it must have exactly one argument</p>
</li>
<li><p class="first">Else if the name of the function is <code class="docutils literal notranslate"><span class="pre">operator==</span></code>, <code class="docutils literal notranslate"><span class="pre">operator!=</span></code>, <code class="docutils literal notranslate"><span class="pre">operator&lt;</span></code>, <code class="docutils literal notranslate"><span class="pre">operator&gt;</span></code>, <code class="docutils literal notranslate"><span class="pre">operator&lt;=</span></code> or <code class="docutils literal notranslate"><span class="pre">operator&gt;=</span></code></p>
<blockquote>
<div><ol class="arabic simple">
<li>It must have exactly two arguments</li>
<li>Its return type must be bool</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">If the environment already has a mapping from that function name to a set of declarations, add this declaration to that set</p>
</li>
<li><p class="first">Otherwise add a new mapping from that function name to a singleton set containing that declaration</p>
</li>
</ol>
</li>
</ol>
</div>
<div class="section" id="other-validation-steps">
<span id="global-validation-label"></span><h3>Other validation steps<a class="headerlink" href="#other-validation-steps" title="Permalink to this headline">¶</a></h3>
<p>We list here these validation steps that don’t cleanly fit in either the building of the global typing environment, or the typing of each function.</p>
<div class="section" id="void-type">
<h4>Void type<a class="headerlink" href="#void-type" title="Permalink to this headline">¶</a></h4>
<p>The void type is a special type that can only appear as the return type of functions.
It must not be part of a composite type (i.e. there is no pointer to void, no array reference to void, no array of void)
It must not be the type of a variable (either at the top-level or in a function), the type of a field of a struct, the type of a function parameter, or the definition of a typedef.</p>
</div>
<div class="section" id="validating-types">
<h4>Validating types<a class="headerlink" href="#validating-types" title="Permalink to this headline">¶</a></h4>
<p>Every type name that appears in the program must be defined (i.e. have a mapping in the environment).</p>
</div>
<div class="section" id="resolving-typedefs">
<h4>Resolving typedefs<a class="headerlink" href="#resolving-typedefs" title="Permalink to this headline">¶</a></h4>
<p>We define a relation “depends on”, as the smallest relation such that:</p>
<ul class="simple">
<li>A typedef that is defined as equal to a structure or another typedef “depends on” this structure or typedef.</li>
<li>A structure “depends on” a typedef or structure if it has a member with the same name.</li>
</ul>
<p>If this relation is cyclic, then the program is invalid.</p>
<p>Then each typedef must be resolved, meaning that each mention of it in the program and in the environment is replaced by its definition.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This last step is guaranteed to terminate thanks to the acyclicity check before it.</p>
</div>
</div>
<div class="section" id="checking-the-coherence-of-operators-and-functions">
<h4>Checking the coherence of operators and functions<a class="headerlink" href="#checking-the-coherence-of-operators-and-functions" title="Permalink to this headline">¶</a></h4>
<p>For every declaration of a function with a name of the form <code class="docutils literal notranslate"><span class="pre">operator&amp;.field</span></code> for some name <code class="docutils literal notranslate"><span class="pre">field</span></code> with argument type <code class="docutils literal notranslate"><span class="pre">thread</span> <span class="pre">T1*</span></code> and return type <code class="docutils literal notranslate"><span class="pre">thread</span> <span class="pre">T2*</span></code>:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Add a declaration of a function <code class="docutils literal notranslate"><span class="pre">operator.field=</span></code> for the same name <code class="docutils literal notranslate"><span class="pre">field</span></code>, with argument types <code class="docutils literal notranslate"><span class="pre">T1</span></code> and <code class="docutils literal notranslate"><span class="pre">T2</span></code>, and return type <code class="docutils literal notranslate"><span class="pre">T1</span></code></li>
<li>Add a declaration of a function <code class="docutils literal notranslate"><span class="pre">operator.field</span></code> for the same name <code class="docutils literal notranslate"><span class="pre">field</span></code>, with argument type <code class="docutils literal notranslate"><span class="pre">T1</span></code> and return type <code class="docutils literal notranslate"><span class="pre">T2</span></code></li>
</ol>
</div></blockquote>
<p>For every declaration of the function <code class="docutils literal notranslate"><span class="pre">operator&amp;[]</span></code> with argument types <code class="docutils literal notranslate"><span class="pre">thread</span> <span class="pre">T1*</span></code> and <code class="docutils literal notranslate"><span class="pre">uint32</span></code>, and return type <code class="docutils literal notranslate"><span class="pre">thread</span> <span class="pre">T2*</span></code>:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Add a declaration of a function <code class="docutils literal notranslate"><span class="pre">operator[]=</span></code> with argument types <code class="docutils literal notranslate"><span class="pre">T1</span></code>, <code class="docutils literal notranslate"><span class="pre">uint32</span></code> and <code class="docutils literal notranslate"><span class="pre">T2</span></code>, and return type <code class="docutils literal notranslate"><span class="pre">T1</span></code></li>
<li>Add a declaration of a function <code class="docutils literal notranslate"><span class="pre">operator[]</span></code> with argument types <code class="docutils literal notranslate"><span class="pre">T1</span></code> and <code class="docutils literal notranslate"><span class="pre">uint32</span></code>, and return type <code class="docutils literal notranslate"><span class="pre">T2</span></code></li>
</ol>
</div></blockquote>
<p>For every function with a name of the form <code class="docutils literal notranslate"><span class="pre">operator.field=</span></code> for some name <code class="docutils literal notranslate"><span class="pre">field</span></code> which is defined:</p>
<blockquote>
<div><ol class="arabic simple">
<li>There must be a function with the name <code class="docutils literal notranslate"><span class="pre">operator.field</span></code> (for the same name <code class="docutils literal notranslate"><span class="pre">field</span></code>) which is defined</li>
<li>For each declaration of the former with arguments type <code class="docutils literal notranslate"><span class="pre">(t1,</span> <span class="pre">t2)</span></code>, there must be a declaration of the latter with argument type <code class="docutils literal notranslate"><span class="pre">(t1)</span></code>, and return type <code class="docutils literal notranslate"><span class="pre">t2</span></code></li>
</ol>
</div></blockquote>
<p>If a function with the name <code class="docutils literal notranslate"><span class="pre">operator[]=</span></code> is defined:</p>
<blockquote>
<div><ol class="arabic simple">
<li>There must be a function with the name <code class="docutils literal notranslate"><span class="pre">operator[]</span></code> which is defined</li>
<li>For each declaration of the former with arguments type <code class="docutils literal notranslate"><span class="pre">(t1,</span> <span class="pre">t2,</span> <span class="pre">t3)</span></code>, there must be a declaration of the latter with argument type <code class="docutils literal notranslate"><span class="pre">(t1,</span> <span class="pre">t2)</span></code>, and return type <code class="docutils literal notranslate"><span class="pre">t3</span></code></li>
</ol>
</div></blockquote>
<p>If there are two function declarations with the same names, number of parameters, and types of their parameters, then the program is invalid.</p>
</div>
</div>
<div class="section" id="typing-of-functions">
<span id="typing-label"></span><h3>Typing of functions<a class="headerlink" href="#typing-of-functions" title="Permalink to this headline">¶</a></h3>
<p>Each function must be well-typed following the rules in this section.</p>
<p>To check that a function is well-typed:</p>
<ol class="arabic simple">
<li>Make a new copy of the global environment (built above)</li>
<li>For each parameter of the function, add a mapping to this typing environment, associating this parameter name to the corresponding type</li>
<li>Check that the function body is well-typed in this typing environment (treating it as a block of statement)</li>
<li>If the return type of the function is <code class="docutils literal notranslate"><span class="pre">void</span></code>, then the set of behaviours of the function body must be included in <code class="docutils literal notranslate"><span class="pre">{Nothing,</span> <span class="pre">Return</span> <span class="pre">Void}</span></code></li>
<li>Else if the return type of the function is a type T, then the set of behaviours of the function body must be <code class="docutils literal notranslate"><span class="pre">{Return</span> <span class="pre">T}</span></code></li>
</ol>
<p>In this section we define the terms above, and in particular, what it means for a statement or an expression to be well-typed.
More formally we define two mutually recursive judgments: “In typing environment Gamma, s is a well-typed statement whose set of behaviours is B” and “In typing environment Gamma, e is a well-typed expression whose type is Tau”.</p>
<p>A type can either be:</p>
<ul>
<li><p class="first">A left-value type with an associated right-value type and an address space</p>
</li>
<li><p class="first">An abstract left-value type with an associated right-value type</p>
</li>
<li><p class="first">A right-value type, which can be any of the following:</p>
<blockquote>
<div><ul class="simple">
<li>A basic type such as <code class="docutils literal notranslate"><span class="pre">bool</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code></li>
<li>A structure type, defined by its name</li>
<li>An enum type, defined by its name</li>
<li><code class="docutils literal notranslate"><span class="pre">void</span></code></li>
<li>An array with an associated right-value type and a size (a number of elements). The size must be a positive integer that fits in 32 bits</li>
<li>A pointer with an associated right-value type and an address space</li>
<li>An array reference with an associated right-value type and an address space</li>
</ul>
</div></blockquote>
</li>
</ul>
<p>Informally, a left-value type is anything whose address can be taken, whereas an abstract left-value type is anything that can be assigned to.
Any value with a left-value type of non-constant address space can be given an abstract left-value type, and any value with an abstract left-value type (or left-value type even with a constant address space) can be given a right-value type, but the opposite to those is not true.</p>
<p>A behaviour is any of the following:</p>
<ul class="simple">
<li>Return of a right-value type</li>
<li>Break</li>
<li>Continue</li>
<li>Fallthrough</li>
<li>Nothing</li>
</ul>
<p>We use these “behaviours” to check the effect of statements on the control flow.</p>
<div class="section" id="typing-statements">
<span id="typing-statements-label"></span><h4>Typing statements<a class="headerlink" href="#typing-statements" title="Permalink to this headline">¶</a></h4>
<p>To check an if-then-else statement:</p>
<ol class="arabic simple">
<li>Check that the condition is a well-typed expression of type bool</li>
<li>Check that the then and else branches are well-typed statements whose behaviours we will respectively call <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">B'</span></code></li>
<li>Check that neither <code class="docutils literal notranslate"><span class="pre">B</span></code> nor <code class="docutils literal notranslate"><span class="pre">B'</span></code> contain a return of a pointer type, or of an array reference type</li>
<li>Then the if-then-else statement is well-typed, and its behaviours is the union of <code class="docutils literal notranslate"><span class="pre">B</span></code> and <code class="docutils literal notranslate"><span class="pre">B'</span></code></li>
</ol>
<div class="math">
<p><img src="images/math/84e46a5ffb3a6085f700f5582674ba48fc793873.png" alt="\begin{align*}
   \ottdruleif{}
\end{align*}"/></p>
</div><p>To check a do-while or for statement:</p>
<ol class="arabic simple">
<li>Check that the condition is well-typed, of type <code class="docutils literal notranslate"><span class="pre">bool</span></code></li>
<li>If it is a for statement, check that the expression that is executed at the end of each iteration is well-typed</li>
<li>Check that the body of the loop is a well-typed statement whose behaviours we will call <code class="docutils literal notranslate"><span class="pre">B</span></code></li>
<li>Check that <code class="docutils literal notranslate"><span class="pre">B</span></code> does not contain a return of a pointer type, or of an array reference type</li>
<li>If Continue is in <code class="docutils literal notranslate"><span class="pre">B</span></code>, remove it</li>
<li>If Break is in <code class="docutils literal notranslate"><span class="pre">B</span></code>, remove it and add Nothing to <code class="docutils literal notranslate"><span class="pre">B</span></code></li>
<li>Then the do-while statement is well-typed, and its behaviours is <code class="docutils literal notranslate"><span class="pre">B</span></code></li>
</ol>
<div class="math">
<p><img src="images/math/4ae5487700815e8319aa9e0b01575b8c3978e6f7.png" alt="\begin{align*}
    \ottdruledoXXwhileXXbreak{}\\
    \ottdruledoXXwhileXXnoXXbreak{}\\
    \ottdruleforXXbreak{}\\
    \ottdruleforXXnoXXbreak{}\\
\end{align*}"/></p>
</div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We do not give rules for while loops, or for if-then statements without an else, because they are syntactic sugar that are eliminated during parsing (see <a class="reference internal" href="#parsing-label"><span class="std std-ref">Parsing</span></a>).</p>
</div>
<p>To check a switch statement:</p>
<ol class="arabic simple">
<li>Check that the expression being switched on is well-typed</li>
<li>Check that its type is either an integer type (<code class="docutils literal notranslate"><span class="pre">int</span></code> or <code class="docutils literal notranslate"><span class="pre">uint</span></code>) or an enum type</li>
<li>Check that each value <code class="docutils literal notranslate"><span class="pre">v</span></code> in a <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">v</span></code> in this switch is well-typed with the same type</li>
<li>Check that no two such cases have the same value</li>
<li>If there is a default, check that there is at least one value in that type which is not covered by the cases</li>
<li>Else check that for all values in that type, there is one case that covers it</li>
<li>Check that the body of each case (and default) is well-typed when treating them as blocks</li>
<li>Check that the behaviours of the last such body does not include Fallthrough</li>
<li>Make a set of behaviours that is the union of the behaviours of all of these bodies</li>
<li>Check that this set contains neither Nothing, nor a Return of a pointer type, nor a Return of an array reference type</li>
<li>If Fallthrough is in this set, remove it</li>
<li>If Break is in this set, remove it and add Nothing</li>
<li>Then the switch statement is well-typed, and its behaviours is this last set</li>
</ol>
<div class="math">
<p><img src="images/math/2aaf5503ee53af97a782e614c93f74af19519915.png" alt="\begin{align*}
   \ottdruleswitchXXbreak{}\\
   \ottdruleswitchXXnoXXbreak{}\\
   \ottdrulecase{}\\
   \ottdruledefault{}\\
   \ottdruleswitchXXblock{}
\end{align*}"/></p>
</div><p>The <code class="docutils literal notranslate"><span class="pre">break;</span></code>, <code class="docutils literal notranslate"><span class="pre">fallthrough;</span></code>, <code class="docutils literal notranslate"><span class="pre">continue;</span></code> and <code class="docutils literal notranslate"><span class="pre">return;</span></code> statements are always well-typed, and their behaviours are respectively {Break}, {Fallthrough}, {Continue} and {Return void}.</p>
<p>The statement <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">e;</span></code> is well-typed if <code class="docutils literal notranslate"><span class="pre">e</span></code> is a well-typed expression with a right-value type T and its behaviours is then {Return T}.</p>
<div class="math">
<p><img src="images/math/59461786bfbe364225cb1f8db711df3fd804622d.png" alt="\begin{align*}
   \ottdrulebreak{}\\
   \ottdrulecontinue{}\\
   \ottdrulefallthrough{}\\
   \ottdrulereturnXXvoid{}\\
   \ottdrulereturn{}\\
\end{align*}"/></p>
</div><p>To check a block:</p>
<ol class="arabic">
<li><p class="first">If it is empty, it is well-typed and its behaviours is always {Nothing}</p>
</li>
<li><p class="first">Else if it starts by a variable declaration:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Check that there is no other statement in that block is a variable declaration sharing the same name.</li>
<li>Check that the given address space is either <code class="docutils literal notranslate"><span class="pre">thread</span></code> or <code class="docutils literal notranslate"><span class="pre">threadgroup</span></code></li>
<li>Make a new typing environment from the current one, in which the variable name is mapped to a left-value type of its given type and address-space</li>
<li>If there is no initializing expression, check that the type of this variable is neither a pointer type nor an array reference type.</li>
<li>Else if there is an initializing expression, check that it is well-typed in this new environment and that its type match the type of the variable</li>
<li>Check that the rest of the block, removing this first statement is well-typed in this new typing environment and has a set of behaviours B.</li>
<li>Then the block is well-typed and has the same set of behaviours B.</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else if this block contains a single statement, check that this statement is well-typed. If it is, then so is this block, and it has the same set of behaviours</p>
</li>
<li><p class="first">Else</p>
<blockquote>
<div><ol class="arabic simple">
<li>Check that this block’s first statement is well-typed</li>
<li>Check that its set of behaviours B contains Nothing.</li>
<li>Remove Nothing from it.</li>
<li>Check that it does not contain Fallthrough</li>
<li>Check that the rest of the block, removing the first statement, is well-typed with a set of behaviours B’.</li>
<li>Then the whole block is well-typed, and its set of behaviour is the union of B and B’.</li>
</ol>
</div></blockquote>
</li>
</ol>
<div class="math">
<p><img src="images/math/50aa85ba1b0e4b18f56db8df91930cf1533c6315.png" alt="\begin{align*}
    \ottdruleemptyXXblock{}\\
    \ottdrulevariableXXdecl{}\\
    \ottdrulevariableXXdeclXXinit{}\\
    \ottdruletrivialXXblock{}\\
    \ottdruleblock{}
\end{align*}"/></p>
</div><div class="admonition-todo admonition" id="index-1">
<p class="first admonition-title">Todo</p>
<p class="last">Change the variable declaration ott rules to support threadgroup local variables
<a class="reference external" href="https://github.com/gpuweb/WHLSL/issues/63">https://github.com/gpuweb/WHLSL/issues/63</a></p>
</div>
<p>Finally a statement that consists of a single expression (followed by a semicolon) is well-typed if that expression is well-typed and its set of behaviours is then {Nothing}.</p>
<div class="math">
<p><img src="images/math/669ac3cc59d18d7ff05c4fed0f934373c34873a1.png" alt="\begin{align*}
    \ottdruleexpr{}
\end{align*}"/></p>
</div></div>
<div class="section" id="typing-expressions">
<span id="typing-expressions-label"></span><h4>Typing expressions<a class="headerlink" href="#typing-expressions" title="Permalink to this headline">¶</a></h4>
<p>Literals are always well-typed and of the following right-value types:</p>
<ul class="simple">
<li><code class="docutils literal notranslate"><span class="pre">true</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code> are always boolean.</li>
<li>float literals are of any floating-point right-value type</li>
<li>unsigned int literals (marked by an <code class="docutils literal notranslate"><span class="pre">u</span></code> at the end) are of any unsigned integer type large enough to contain them</li>
<li>int literals are of any integer type large enough to contain them</li>
</ul>
<p><code class="docutils literal notranslate"><span class="pre">null</span></code> is always well-typed and its type can be any pointer or array reference type (depending on which is required for validation to succeed).</p>
<p>The type of an expression in parentheses, is the type of the expression in the parentheses</p>
<p>A comma expression is well-typed if both of its operands are well-typed. In that case, its type is the right-value type of its second operand.</p>
<div class="math">
<p><img src="images/math/3a4bcacc3e539023efb0727bdd596fa05ed95b85.png" alt="\begin{align*}
    \ottdruleliteralXXtrue{}\\
    \ottdruleliteralXXfalse{}\\
    \ottdrulenullXXlitXXarrayXXref{}\\
    \ottdrulenullXXlitXXptr{}\\
    \ottdruleparens{}\\
    \ottdrulecomma{}
\end{align*}"/></p>
</div><p>To check that a boolean or, or a boolean and is well-typed, check that both of its operands are well-typed and of type bool.</p>
<p>To check that a ternary conditional is well-typed:</p>
<ol class="arabic simple">
<li>Check that its condition is well-typed and of type bool</li>
<li>Check that both of its branches are well-typed</li>
<li>Check that the types of its branches are both right-value types and the same</li>
<li>Check that this same type is neither a pointer type nor an array reference type.</li>
<li>Then the whole expression is well-typed, and of that type</li>
</ol>
<div class="math">
<p><img src="images/math/fc7839ceec094a924ff60cde9a0c117c4ba46cca.png" alt="\begin{align*}
    \ottdruleor{}\\
    \ottdruleand{}\\
    \ottdruleternary{}
\end{align*}"/></p>
</div><p>To check that an assignment is well-typed:</p>
<ol class="arabic simple">
<li>Check that the expression on the right side of the <code class="docutils literal notranslate"><span class="pre">=</span></code> is well-typed with a right-value type “tval”</li>
<li>Check that “tval” is neither a pointer type nor an array reference type</li>
<li>Check that the expression on the left side is well-typed with an abstract left-value type</li>
<li>Check that the right-value type associated with this abstract left-value type is “tval”</li>
<li>Then the assignment is well-typed, and its type is “tval”</li>
</ol>
<div class="math">
<p><img src="images/math/5b2d4d25688d8fbe233281aba951eda37d3c7d24.png" alt="\begin{align*}
    \ottdruleassignment{}
\end{align*}"/></p>
</div><p>If an expression is well-typed and its type is an abstract left-value type, it can also be treated as if it were of the associated right-value type.
If an expression is well-typed and its type is a left-value type, and its address space is not constant, it can also be treated as if it were of the associated abstract left-value type.
If an expression is well-typed and its type is a left-value type, it can also be treated as if it were of the associated right-value type.</p>
<p>A variable name is well-typed if it is in the typing environment. In that case, its type is whatever it is mapped to in the typing environment,</p>
<p>An expression <code class="docutils literal notranslate"><span class="pre">&amp;e</span></code> (respectively <code class="docutils literal notranslate"><span class="pre">*e</span></code>) is well-typed and with a pointer type (respectively with a left-value type) if <code class="docutils literal notranslate"><span class="pre">e</span></code> is well-typed with a left-value type (respectively of a pointer type).
The associated right-value types and address spaces are left unchanged by these two operators.</p>
<p>An expression <code class="docutils literal notranslate"><span class="pre">&#64;e</span></code> is well-typed and with an array reference type if <code class="docutils literal notranslate"><span class="pre">e</span></code> is well-typed with a left-value type.
The associated right-value types and address spaces are left unchanged by this operator.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The dynamic behaviour depends on whether the expression is a left-value array type or not, but it makes no difference during validation.
<code class="docutils literal notranslate"><span class="pre">&#64;x</span></code> for a variable <code class="docutils literal notranslate"><span class="pre">x</span></code> with a non-array type is valid, it will merely produce an array reference for which only the index 0 can be used.</p>
</div>
<div class="math">
<p><img src="images/math/20f5e61dc9694b471c2b474f129ab96cf232856f.png" alt="\begin{align*}
    \ottdrulealvalXXtoXXrval{}\\
    \ottdrulelvalXXtoXXalval{}\\
    \ottdrulelvalXXtoXXrval{}\\
    \ottdrulevariableXXname{}\\
    \ottdruleaddressXXtaking{}\\
    \ottdruleptrXXderef{}\\
    \ottdruletakeXXrefXXlval{}
\end{align*}"/></p>
</div><p>To check a dot expression of the form <code class="docutils literal notranslate"><span class="pre">e.foo</span></code> (for an expression <code class="docutils literal notranslate"><span class="pre">e</span></code> and an identifier <code class="docutils literal notranslate"><span class="pre">foo</span></code>):</p>
<ol class="arabic">
<li><p class="first">If <code class="docutils literal notranslate"><span class="pre">e</span></code> is well-typed</p>
<blockquote>
<div><ol class="arabic simple">
<li><dl class="first docutils">
<dt>If <code class="docutils literal notranslate"><span class="pre">e</span></code> has a left-value type, and there is a function called <code class="docutils literal notranslate"><span class="pre">operator&amp;.foo</span></code> with a first parameter whose type is a pointer to the same right-value type with the same address space,</dt>
<dd>then the whole expression is well-typed, and has a left-value type corresponding to the right-value type and address-space of the return type of that function.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Else if <code class="docutils literal notranslate"><span class="pre">e</span></code> has an abstract left-value type, and there is a function called <code class="docutils literal notranslate"><span class="pre">operator.foo=</span></code> with a first parameter whose type is the corresponding right-value type,</dt>
<dd>then the whole expression is well-typed, and has an abstract left-value type corresponding to the type of the second parameter of that function.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Else if there is a function called <code class="docutils literal notranslate"><span class="pre">operator.foo</span></code> with a parameter whose type matches the type of <code class="docutils literal notranslate"><span class="pre">e</span></code>,</dt>
<dd>then the whole expression is well-typed and has the return type of that function.</dd>
</dl>
</li>
<li>Else the expression is ill-typed.</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else if <code class="docutils literal notranslate"><span class="pre">e</span></code> is an identifier</p>
<blockquote>
<div><ol class="arabic simple">
<li>Check that there is an enum with that name in the global environment</li>
<li>Check that this enum has an element named <code class="docutils literal notranslate"><span class="pre">foo</span></code></li>
<li>Then <code class="docutils literal notranslate"><span class="pre">e.foo</span></code> is well-typed, with the type of that enum</li>
<li>And replace it by the corresponding value</li>
</ol>
</div></blockquote>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Replacing e.foo by its value in the case of an enum is a bit weird of a thing to do at typing time, but it simplifies the writing of the execution rules if we can assume that every dot operator that we see corresponds to a getter, setter, or address-taker.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Please note that a local variable declaration can shadow a global enum declaration.</p>
</div>
<p>To check that an array dereference <code class="docutils literal notranslate"><span class="pre">e1[e2]</span></code> is well-typed:</p>
<ol class="arabic simple">
<li>Check that <code class="docutils literal notranslate"><span class="pre">e2</span></code> is well-typed with the type <code class="docutils literal notranslate"><span class="pre">uint32</span></code></li>
<li>Check that <code class="docutils literal notranslate"><span class="pre">e1</span></code> is well-typed</li>
<li>If the type of <code class="docutils literal notranslate"><span class="pre">e1</span></code> is an array reference whose associated type is <code class="docutils literal notranslate"><span class="pre">T</span></code>, then the whole expression is well-typed, and its type is a left-value with an associated type of <code class="docutils literal notranslate"><span class="pre">T</span></code>, and the same address space as the type of <code class="docutils literal notranslate"><span class="pre">e1</span></code></li>
<li>Else if <code class="docutils literal notranslate"><span class="pre">e1</span></code> has a left-value type, and there is a function called <code class="docutils literal notranslate"><span class="pre">operator&amp;[]</span></code> with a first parameter whose type is a pointer to the same right-value type with the same address space,
then the whole expression is well-typed, and has a left-value type corresponding to the right-value type and address-space of the return type of that function.</li>
<li><dl class="first docutils">
<dt>Else if <code class="docutils literal notranslate"><span class="pre">e1</span></code> has an abstract left-value type, and there is a function called <code class="docutils literal notranslate"><span class="pre">operator[]=</span></code> with a first parameter whose type is the corresponding right-value type,</dt>
<dd>then the whole expression is well-typed, and has an abstract left-value type corresponding to the type of the third parameter of that function.</dd>
</dl>
</li>
<li><dl class="first docutils">
<dt>Else if there is a function called <code class="docutils literal notranslate"><span class="pre">operator.[]</span></code> with a parameter whose type matches the type of <code class="docutils literal notranslate"><span class="pre">e1</span></code>,</dt>
<dd>then the whole expression is well-typed and has the return type of that function.</dd>
</dl>
</li>
<li>Else the expression is ill-typed</li>
</ol>
<div class="math">
<p><img src="images/math/73868bd7124037446cc433c1df796bf20ef8d42e.png" alt="\begin{align*}
    \ottdrulearrayXXrefXXindex{}
\end{align*}"/></p>
</div><p>To check that an expression <code class="docutils literal notranslate"><span class="pre">e++</span></code>, or <code class="docutils literal notranslate"><span class="pre">e--</span></code> is well-typed:</p>
<ol class="arabic simple">
<li>Check that <code class="docutils literal notranslate"><span class="pre">e</span></code> is well-typed, with an abstract left-value type</li>
<li>Check that a call to <code class="docutils literal notranslate"><span class="pre">operator+(e,</span> <span class="pre">1)</span></code> (respectively <code class="docutils literal notranslate"><span class="pre">operator-(e,</span> <span class="pre">1)</span></code>) would be well-typed, with a right-value type that matches <code class="docutils literal notranslate"><span class="pre">e</span></code></li>
<li>Then the expression is well-typed, and of the right-value type of <code class="docutils literal notranslate"><span class="pre">e</span></code></li>
</ol>
<p>To check that an expression <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">+=</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">-=</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">*=</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">/=</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">%=</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">^=</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">&amp;=</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">|=</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">&gt;&gt;=</span> <span class="pre">e2</span></code>, or <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">&lt;&lt;=</span> <span class="pre">e2</span></code>:</p>
<ol class="arabic simple">
<li>Check that <code class="docutils literal notranslate"><span class="pre">e1</span></code> is well-typed, with an abstract left-value type</li>
<li>Check that <code class="docutils literal notranslate"><span class="pre">e2</span></code> is well-typed</li>
<li>Check that a call to <code class="docutils literal notranslate"><span class="pre">operator+(e1,</span> <span class="pre">e2)</span></code> (respectively with the corresponding operators) would be well-typed, with a right-value type that matches <code class="docutils literal notranslate"><span class="pre">e1</span></code></li>
<li>Then the expression is well-typed, and of the right-value type of <code class="docutils literal notranslate"><span class="pre">e1</span></code></li>
</ol>
<div class="math">
<p><img src="images/math/58a41211481f8980151d13b31a512709b0d556f1.png" alt="\begin{align*}
    \ottdrulepostfixXXincr{}\\
    \ottdruleoperatorXXplusXXequal{}
\end{align*}"/></p>
</div><p>To check that a function call is well-typed:</p>
<ol class="arabic">
<li><p class="first">Check that each argument is well-typed</p>
</li>
<li><p class="first">Make a set of all the functions in the global environment that share the same name and number of parameters, and that is not an entry point</p>
</li>
<li><p class="first">For each function in that set:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Check that each argument can be given a type that match the type of the parameter</li>
<li>Otherwise, remove the function from the set</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Check that the set now contains a single function</p>
</li>
<li><p class="first">Then the function call is well-typed, and its type is the return type of that function</p>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Our overloading resolution is only this simple because this version of the language does not have generics.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Entry points cannot be called from within a shader. A function is an entry point if and only if it is marked with one of <code class="docutils literal notranslate"><span class="pre">vertex</span></code>, <code class="docutils literal notranslate"><span class="pre">fragment</span></code> or <code class="docutils literal notranslate"><span class="pre">compute</span></code>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A consequence of the rule that overloading must be resolved without ambiguity is that if there are two implementations of a function <code class="docutils literal notranslate"><span class="pre">foo</span></code>
that take respectively an int and a short, then the program <code class="docutils literal notranslate"><span class="pre">foo(42)</span></code> is invalid (as it could refer to either of these implementations).
The programmer can easily make their intent clear with something like <code class="docutils literal notranslate"><span class="pre">int</span> <span class="pre">x</span> <span class="pre">=</span> <span class="pre">42;</span> <span class="pre">foo(x);</span></code>.</p>
</div>
<div class="admonition-todo admonition" id="index-2">
<p class="first admonition-title">Todo</p>
<p class="last">This rule for overloading resolution is very different from the implementation, the two should be brought back in sync one way or another.
<a class="reference external" href="https://github.com/gpuweb/WHLSL/issues/313">https://github.com/gpuweb/WHLSL/issues/313</a></p>
</div>
</div>
</div>
<div class="section" id="phase-4-annotations-for-execution">
<h3>Phase 4. Annotations for execution<a class="headerlink" href="#phase-4-annotations-for-execution" title="Permalink to this headline">¶</a></h3>
<p>We resolved each overloaded function call in the previous section. They must now be annotated with which function is actually being called.</p>
<p>Every variable declaration, every function parameter, and every postfix increment/decrement must be associated with a unique store identifier.
This identifier in turn refers to a set of contiguous bytes, of the right size; these sets are disjoint.</p>
<p>Each control barrier must be annotated with a unique barrier identifier.</p>
<p>Each branch, switch, loop, ternary expression, boolean or expression and boolean and expression must be annotated with a unique divergence point identifier.</p>
<p>Every variable declaration that does not have an initializing value, must get an initializing value that is the default value for its type.
These default values are computed as follows:</p>
<ul class="simple">
<li>The default value for integer types is <code class="docutils literal notranslate"><span class="pre">0</span></code></li>
<li>The default value for floating point types is <code class="docutils literal notranslate"><span class="pre">0.0</span></code></li>
<li>The default value for booleans is <code class="docutils literal notranslate"><span class="pre">false</span></code></li>
<li>The default value for enums is the element of the enum whose associated integer values is 0</li>
<li>The default value for pointers and array references is <code class="docutils literal notranslate"><span class="pre">null</span></code></li>
<li>The default value for an array is an array of the right size filled with the default values for its element type</li>
<li>The default value for a structure type is a structure whose elements are all given their respective default values</li>
</ul>
<p>Every load and store must also be annotated with a size in bytes.</p>
<ul class="simple">
<li>The size of primitive types, pointers and array references is implementation defined.</li>
<li>The size of enums is the size of the underlying type</li>
<li>The size of arrays is their number of elements multiplied by the size of one element</li>
<li>The size of structs is computed in the same way as for C structs, and includes padding</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The fact that padding is included in the size, combined with the dynamic rules in the next section, means that copying a struct
also copies any padding bits. This may be observable by the outside world depending on where the store occurs.</p>
</div>
<p>Finally, every array dereference (the <code class="docutils literal notranslate"><span class="pre">[]</span></code> operator) must be annotated with the stride, i.e. the size of the elements of the corresponding array.
This size is computed in exactly the way described above.
If the first operand is either an array or a left-value type associated with an array type, the access must also be annotated with the statically known size of the array.</p>
</div>
<div class="section" id="phase-5-verifying-the-absence-of-recursion">
<h3>Phase 5. Verifying the absence of recursion<a class="headerlink" href="#phase-5-verifying-the-absence-of-recursion" title="Permalink to this headline">¶</a></h3>
<p>WHLSL does not support recursion (for efficient compilation to GPUs).
So once all overloaded function calls have been resolved, we must do one last check.</p>
<p>We create a relationship “may call” that connects two function declarations <code class="docutils literal notranslate"><span class="pre">f</span></code> and <code class="docutils literal notranslate"><span class="pre">g</span></code> if there is a call to <code class="docutils literal notranslate"><span class="pre">g</span></code> in the body of <code class="docutils literal notranslate"><span class="pre">f</span></code> (after resolving overloading).
If this relationship is cyclic, then the program is invalid.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">This check is done on function declarations, not on function names, so if for example foo(int) calls foo(short), it is not considered recursion, as they are different functions
after resolution of overloading.</p>
</div>
</div>
</div>
<div class="section" id="dynamic-rules">
<h2>Dynamic rules<a class="headerlink" href="#dynamic-rules" title="Permalink to this headline">¶</a></h2>
<div class="section" id="definitions">
<h3>Definitions<a class="headerlink" href="#definitions" title="Permalink to this headline">¶</a></h3>
<p>We split the semantics in two parts: a per-thread execution semantics that does not know anything about concurrency or the memory, and a global set of rules for
loads, stores, barriers and the like.</p>
<p>The per-thread semantics is a fairly classic small-step operational semantics, meaning that it describes a list of possible transitions that the program can
take in one step.
The per-thread state is made of a few element:</p>
<ul class="simple">
<li>The program being executed. Each transition transforms it.</li>
<li>A divergence stack. This is a stack of pairs of divergence point identifiers and values, which tracks whether we are in a branch, and is used by the rules for barriers and derivatives to check that control-flow is uniform.</li>
<li>An environment. This is a mapping from variable names to values and is used to keep track of arguments and variables declared in the function.</li>
</ul>
<p>Each transition is a statement of the form “With environment <img class="math" src="images/math/e13213b284578cff04a56a0bc6a3827dd8fe74d1.png" alt="\rho"/>, if some conditions are respected, the program may be transformed into the following, emitting the following memory events, and modifying the divergence stack in these ways.”</p>
<p>In some of these rules we use <code class="docutils literal notranslate"><span class="pre">ASSERT</span></code> to provide some properties that are true either by construction or thanks to the validation rules of the previous section.
Such assertions are not tests that must be done by any implementation, they are merely hints to our intent.</p>
</div>
<div class="section" id="execution-of-statements">
<h3>Execution of statements<a class="headerlink" href="#execution-of-statements" title="Permalink to this headline">¶</a></h3>
<div class="section" id="blocks-and-variable-declarations">
<h4>Blocks and variable declarations<a class="headerlink" href="#blocks-and-variable-declarations" title="Permalink to this headline">¶</a></h4>
<p>The program fragments that we use to define our semantics are richer than just the syntactically correct programs. In particular, we allow annotating blocks
(sequences of statements between braces) with an environment. This is useful to formalize lexical scoping.</p>
<p>Here is how to reduce a block by one step:</p>
<ol class="arabic simple">
<li>If the block is not annotated, annotate it with the environment</li>
<li>If the first statement of the block is an empty block, remove it</li>
<li>Else if the first statement of the block is a terminator (break, continue, fallthrough, or return), replace the entire block by it.</li>
<li>Else if the first statement of the block is a variable declaration:<ol class="arabic">
<li>Make a new environment from the one that annotates the block, mapping the variable name to its store identifier.</li>
<li>If the variable declaration has an initializing expression that can be reduced, reduce it using the new environment</li>
<li>Else:<ol class="arabic">
<li>Change the annotation of the block to the new environment.</li>
<li>Emit a store to the store identifier of the declaration, of the initializing value</li>
<li>Remove this variable declaration from the block</li>
</ol>
</li>
</ol>
</li>
<li>Else reduce the first statement of the block, using the environment that the block was annotated with (not the top-level environment)</li>
</ol>
<div class="math">
<p><img src="images/math/68f476d3aca624174394f4ba0260f50c382b989a.png" alt="\begin{align*}
    \ottdruleblockXXannotate{}\\
    \ottdruleblockXXnextXXstmt{}\\
    \ottdruleblockXXterminator{}\\
    \ottdruleblockXXvdeclXXreduce{}\\
    \ottdruleblockXXvdeclXXcomplete{}\\
    \ottdruleblockXXvdecl{}\\
    \ottdruleblockXXreduce{}
\end{align*}"/></p>
</div></div>
<div class="section" id="branches">
<h4>Branches<a class="headerlink" href="#branches" title="Permalink to this headline">¶</a></h4>
<p>We add another kind of statement: the <code class="docutils literal notranslate"><span class="pre">Join(s)</span></code> construct, that takes as argument another statement <code class="docutils literal notranslate"><span class="pre">s</span></code>.</p>
<p>Here is how to reduce a branch (if-then-else construct, remember that if-then is just syntactic sugar that was eliminated during parsing) by one step:</p>
<ol class="arabic simple">
<li>If the expression in the if is <code class="docutils literal notranslate"><span class="pre">true</span></code> or <code class="docutils literal notranslate"><span class="pre">false</span></code>.<ol class="arabic">
<li>Push that value and the divergence point identifier of the branch on the divergence stack</li>
<li>Replace the branch by the statement in the then (for <code class="docutils literal notranslate"><span class="pre">true</span></code>) or else (for <code class="docutils literal notranslate"><span class="pre">false</span></code>) branch, wrapped in the <code class="docutils literal notranslate"><span class="pre">Join</span></code> construct</li>
</ol>
</li>
<li>Else reduce that expression</li>
</ol>
<div class="math">
<p><img src="images/math/021d3be669ef84684a63f57fe783fd5ebe56728a.png" alt="\begin{align*}
    \ottdruleifXXtrue{}\\
    \ottdruleifXXfalse{}\\
    \ottdruleifXXreduce{}
\end{align*}"/></p>
</div><p>Here is how to reduce a <code class="docutils literal notranslate"><span class="pre">Join(s)</span></code> statement:</p>
<ol class="arabic simple">
<li>If the argument of the <code class="docutils literal notranslate"><span class="pre">Join</span></code> is a terminator (<code class="docutils literal notranslate"><span class="pre">break;</span></code>, <code class="docutils literal notranslate"><span class="pre">continue;</span></code>, <code class="docutils literal notranslate"><span class="pre">fallthrough;</span></code>, or <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">e?;</span></code>) or an empty block<ol class="arabic">
<li>ASSERT(the divergence stack is not empty)</li>
<li>Pop the last element from the divergence stack</li>
<li>Replace the <code class="docutils literal notranslate"><span class="pre">Join</span></code> statement by its argument</li>
</ol>
</li>
<li>Else reduce its argument</li>
</ol>
<div class="math">
<p><img src="images/math/2a164651baca5cfd104d1941967f0841a77b4829.png" alt="\begin{align*}
    \ottdrulejoinXXelim{}\\
    \ottdrulejoinXXreduce{}
\end{align*}"/></p>
</div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Popping the last element from the divergence stack never fails, as a Join only appears when eliminating a branch, which pushes a value on it.</p>
</div>
</div>
<div class="section" id="switches">
<h4>Switches<a class="headerlink" href="#switches" title="Permalink to this headline">¶</a></h4>
<p>We add another kind of statement: the <code class="docutils literal notranslate"><span class="pre">Cases(..)</span></code> construct that takes as argument a sequence of statements.
Informally it represents the different cases of a switch, and deals with the <code class="docutils literal notranslate"><span class="pre">fallthrough;</span></code> and <code class="docutils literal notranslate"><span class="pre">break;</span></code> statements.</p>
<p>Here is how to reduce a switch statement by one step:</p>
<ol class="arabic">
<li><p class="first">If the expression in the switch can be reduced, reduce it by one step</p>
</li>
<li><p class="first">Else if it is an integer or enum value <code class="docutils literal notranslate"><span class="pre">val</span></code> and there is a <code class="docutils literal notranslate"><span class="pre">case</span> <span class="pre">val:</span></code> in the switch:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Wrap the corresponding sequence of statements into a block (turning it into a single statement)</li>
<li>Do the same for each sequence of statements until the end of the switch</li>
<li>Replace the entire switch by a <code class="docutils literal notranslate"><span class="pre">Cases</span></code> construct, taking as argument these resulting statements in source order</li>
<li>Push <code class="docutils literal notranslate"><span class="pre">val</span></code> and the divergence point identifier of the switch on the divergence stack</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else</p>
<blockquote>
<div><ol class="arabic simple">
<li>ASSERT(the expression in the switch is an integer or enum value <code class="docutils literal notranslate"><span class="pre">val</span></code>)</li>
<li>ASSERT(there is a <code class="docutils literal notranslate"><span class="pre">default:</span></code> case in the switch)</li>
<li>Find the <code class="docutils literal notranslate"><span class="pre">default</span></code> case, and wrap the corresponding sequence of statements into a block (turning it into a single statement)</li>
<li>Do the same for each sequence of statements until the end of the switch</li>
<li>Replace the entire switch by a <code class="docutils literal notranslate"><span class="pre">Cases</span></code> construct, taking as argument these resulting statements in source order</li>
<li>Push <code class="docutils literal notranslate"><span class="pre">val</span></code> and the divergence point identifier of the switch on the divergence stack</li>
</ol>
</div></blockquote>
</li>
</ol>
<div class="math">
<p><img src="images/math/09e0c71061c7e20dae69a99a4172237248383d27.png" alt="\begin{align*}
    \ottdruleswitchXXreduce{}\\
    \ottdruleswitchXXcaseXXfound{}\\
    \ottdruleswitchXXdefault{}
\end{align*}"/></p>
</div><p>Here is how to reduce a <code class="docutils literal notranslate"><span class="pre">Cases</span></code> construct by one step:</p>
<ol class="arabic simple">
<li>ASSERT(the construct has at least one argument)</li>
<li>If the first argument is the <code class="docutils literal notranslate"><span class="pre">fallthrough;</span></code> statement, remove it (reducing the total number of arguments by 1)</li>
<li>Else if the first argument is the <code class="docutils literal notranslate"><span class="pre">break;</span></code> statement:<ol class="arabic">
<li>ASSERT(the divergence stack is not empty)</li>
<li>Pop the last element from the divergence stack</li>
<li>Replace the entire construct by an empty block</li>
</ol>
</li>
<li>Else if the first argument is another terminator statement, that cannot be reduced (i.e. <code class="docutils literal notranslate"><span class="pre">continue;</span></code>, <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">value;</span></code> or <code class="docutils literal notranslate"><span class="pre">return;</span></code>)<ol class="arabic">
<li>ASSERT(the divergence stack is not empty)</li>
<li>Pop the last element from the divergence stack</li>
<li>Replace the entire construct by its first argument</li>
</ol>
</li>
<li>Else reduce the first argument by one step</li>
</ol>
<div class="math">
<p><img src="images/math/b443d8e15a9a69bb2825e4600733a3784294049a.png" alt="\begin{align*}
    \ottdrulecasesXXfallthrough{}\\
    \ottdrulecasesXXbreak{}\\
    \ottdrulecasesXXotherXXterminator{}\\
    \ottdrulecasesXXreduce{}
\end{align*}"/></p>
</div></div>
<div class="section" id="loops">
<h4>Loops<a class="headerlink" href="#loops" title="Permalink to this headline">¶</a></h4>
<p>We add yet another kind of statement: the <code class="docutils literal notranslate"><span class="pre">Loop(s,</span> <span class="pre">s',</span> <span class="pre">s'')</span></code> construct that takes as arguments three statements.
Informally, its first argument represents the current iteration of a loop, its second argument is to be executed at the end of the iteration, and its third argument is a continuation for the rest of the loop.</p>
<p>Any <code class="docutils literal notranslate"><span class="pre">do</span> <span class="pre">s</span> <span class="pre">while(e);</span></code> statement is reduced to the following in one step: <code class="docutils literal notranslate"><span class="pre">Loop(s,</span> <span class="pre">{},</span> <span class="pre">if(e)</span> <span class="pre">do</span> <span class="pre">s</span> <span class="pre">while(e);</span> <span class="pre">else</span> <span class="pre">{})</span></code>, keeping the same divergence point identifier.
Any <code class="docutils literal notranslate"><span class="pre">for</span> <span class="pre">(;e;e')</span> <span class="pre">s</span></code> statement is reduced to the following in one step <code class="docutils literal notranslate"><span class="pre">if</span> <span class="pre">(e)</span> <span class="pre">Loop(s,</span> <span class="pre">e';,</span> <span class="pre">for(;e;e')</span> <span class="pre">s)</span> <span class="pre">else</span> <span class="pre">{}</span></code>, keeping the same divergence point identifier.</p>
<div class="math">
<p><img src="images/math/29573dc1b9638fcf2fc22572395b4edebe7da97e.png" alt="\begin{align*}
    \ottdruledoXXwhileXXloop{}\\
    \ottdruleforXXloop{}
\end{align*}"/></p>
</div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">while loops are desugared into do while loops, see <a class="reference internal" href="#parsing-label"><span class="std std-ref">Parsing</span></a>.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">we only treat the case where for loops have no initialization, because it is desugared, see <a class="reference internal" href="#parsing-label"><span class="std std-ref">Parsing</span></a>.</p>
</div>
<p>Here is how to reduce a <code class="docutils literal notranslate"><span class="pre">Loop(s,</span> <span class="pre">s')</span></code> statement by one step:</p>
<ol class="arabic">
<li><p class="first">If <code class="docutils literal notranslate"><span class="pre">s</span></code> is the <code class="docutils literal notranslate"><span class="pre">break;</span></code> statement, replace the whole construct by the empty block: <code class="docutils literal notranslate"><span class="pre">{}</span></code></p>
</li>
<li><p class="first">Else if <code class="docutils literal notranslate"><span class="pre">s</span></code> is the empty block or the <code class="docutils literal notranslate"><span class="pre">continue;</span></code> statement</p>
<blockquote>
<div><ol class="arabic simple">
<li>If the second argument <code class="docutils literal notranslate"><span class="pre">s'</span></code> is the empty statement, replace the whole construct by its third argument <code class="docutils literal notranslate"><span class="pre">s''</span></code></li>
<li>Else reduce <code class="docutils literal notranslate"><span class="pre">s'</span></code> by a step</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else if <code class="docutils literal notranslate"><span class="pre">s</span></code> is another terminator (<code class="docutils literal notranslate"><span class="pre">fallthrough;</span></code>, <code class="docutils literal notranslate"><span class="pre">return;</span></code> or <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">rval;</span></code>), replace the whole construct by it</p>
</li>
<li><p class="first">Else reduce <code class="docutils literal notranslate"><span class="pre">s</span></code> by one step</p>
</li>
</ol>
<div class="math">
<p><img src="images/math/3997f39dd8c9d2f56f6b209a0d018ebf65f33cb7.png" alt="\begin{align*}
    \ottdruleloopXXbreak{}\\
    \ottdruleloopXXnextXXiteration{}\\
    \ottdruleloopXXincrement{}\\
    \ottdruleloopXXotherXXterminator{}\\
    \ottdruleloopXXreduce{}
\end{align*}"/></p>
</div><div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">These operations do not need to explicitly modify the divergence stack, because each iteration of a loop executes an <code class="docutils literal notranslate"><span class="pre">if</span></code> statement that does it.</p>
</div>
</div>
<div class="section" id="barriers-and-uniform-control-flow">
<h4>Barriers and uniform control flow<a class="headerlink" href="#barriers-and-uniform-control-flow" title="Permalink to this headline">¶</a></h4>
<p>There is no rule in the per-thread semantics for <em>control barriers</em>.
Instead, there is a rule in the global semantics, saying that if all threads are at a control barrier instruction with the same identifier, and their divergence stacks are identical, then they may all advance atomically, replacing the barrier by an empty block.</p>
</div>
<div class="section" id="other">
<h4>Other<a class="headerlink" href="#other" title="Permalink to this headline">¶</a></h4>
<p>If a statement is just an expression (<code class="docutils literal notranslate"><span class="pre">effectfulExpr</span></code> in the grammar), it is either discarded (if it is a value) or reduced by one step (otherwise).</p>
<p>If a statement is a return followed by an expression, and the expression can be reduced, then the statement can as well by reducing the expression.</p>
<div class="math">
<p><img src="images/math/096ea45df57395c87c8d32cecff3225023b72076.png" alt="\begin{align*}
    \ottdruleeffectfulXXexprXXreduce{}\\
    \ottdruleeffectfulXXexprXXelim{}\\
    \ottdrulereturnXXreduce{}\\
\end{align*}"/></p>
</div><p>The standard library also offers atomic operations and fences (a.k.a. <em>memory barriers</em>, not to be confused with <em>control barriers</em>).
Each of these emit a specific memory event when they are executed, whose semantics is described in the memory model section.</p>
</div>
</div>
<div class="section" id="execution-of-expressions">
<h3>Execution of expressions<a class="headerlink" href="#execution-of-expressions" title="Permalink to this headline">¶</a></h3>
<p>We define the following kinds of values:</p>
<ul class="simple">
<li>Integers, floats, booleans and other primitives provided by the standard library</li>
<li>Pointers. These have an address and an address space</li>
<li>Left values. These also have an address and an address space</li>
<li>A special Invalid left-value, used to represent the dereferencing of out-of-bounds accesses and the dereferencing of <code class="docutils literal notranslate"><span class="pre">null</span></code></li>
<li>Array references. These have a base address, an address space and a size</li>
<li>Struct values. These are a sequence of bytes of the right size, and can be interpreted as a tuple of their elements (plus padding bits)</li>
</ul>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Abstract left-value types were used in the typing section to represent things that can be assigned to.
At runtime they are either left-values, or normal values with a setter applicable to them.</p>
</div>
<p>In this section we describe how to reduce each kind of expression to another expression or to a value.
Left values are the only kind of values that can be further reduced.</p>
<div class="section" id="operations-affecting-control-flow">
<h4>Operations affecting control-flow<a class="headerlink" href="#operations-affecting-control-flow" title="Permalink to this headline">¶</a></h4>
<p>Just like we added <code class="docutils literal notranslate"><span class="pre">Join</span></code>, <code class="docutils literal notranslate"><span class="pre">Cases</span></code> and <code class="docutils literal notranslate"><span class="pre">Loop</span></code> construct to deal with control-flow affecting statements, we add a <code class="docutils literal notranslate"><span class="pre">JoinExpr</span></code> construct to deal with control-flow affecting expressions.
<code class="docutils literal notranslate"><span class="pre">JoinExpr</span></code> takes as argument an expression and return an expression. Its only use is (informally) as a marker that the divergence stack will have to be popped to access its content.</p>
<p>There are three kinds of expressions that can cause a divergence in control-flow: the boolean and (i.e. <code class="docutils literal notranslate"><span class="pre">&amp;&amp;</span></code>, that short-circuits), the boolean or (i.e. <code class="docutils literal notranslate"><span class="pre">||</span></code>, that also short-circuits), and ternary conditions.</p>
<p>To reduce a boolean and by one step:</p>
<ol class="arabic">
<li><p class="first">If its first operand can be reduced, reduce it</p>
</li>
<li><p class="first">Else if its first operand is <code class="docutils literal notranslate"><span class="pre">false</span></code>, replace the whole operation by <code class="docutils literal notranslate"><span class="pre">false</span></code>.</p>
</li>
<li><p class="first">Else</p>
<blockquote>
<div><ol class="arabic simple">
<li>ASSERT(its first operand is <code class="docutils literal notranslate"><span class="pre">true</span></code>)</li>
<li>Push <code class="docutils literal notranslate"><span class="pre">true</span></code> and the corresponding divergence point identifier on the divergence stack.</li>
<li>Replace the whole operation by its second operand wrapped in a <code class="docutils literal notranslate"><span class="pre">JoinExpr</span></code> construct.</li>
</ol>
</div></blockquote>
</li>
</ol>
<div class="math">
<p><img src="images/math/e50817491ef91ac6bda0efc17b04e161d4fda27b.png" alt="\begin{align*}
    \ottdruleandXXreduce{}\\
    \ottdruleandXXfalse{}\\
    \ottdruleandXXtrue{}
\end{align*}"/></p>
</div><p>Very similarly, to reduce a boolean or by one step:</p>
<ol class="arabic">
<li><p class="first">If its first operand can be reduced, reduce it</p>
</li>
<li><p class="first">Else if its first operand is <code class="docutils literal notranslate"><span class="pre">true</span></code>, replace the whole operation by <code class="docutils literal notranslate"><span class="pre">true</span></code>.</p>
</li>
<li><p class="first">Else</p>
<blockquote>
<div><ol class="arabic simple">
<li>ASSERT(its first operand is <code class="docutils literal notranslate"><span class="pre">false</span></code>)</li>
<li>Push <code class="docutils literal notranslate"><span class="pre">false</span></code> and the corresponding divergence point identifier on the divergence stack.</li>
<li>Replace the whole operation by its second operand wrapped in a <code class="docutils literal notranslate"><span class="pre">JoinExpr</span></code> construct.</li>
</ol>
</div></blockquote>
</li>
</ol>
<div class="math">
<p><img src="images/math/5794d77fc5438cc216ff878bcd27d266b3495f33.png" alt="\begin{align*}
    \ottdruleorXXreduce{}\\
    \ottdruleorXXtrue{}\\
    \ottdruleorXXfalse{}
\end{align*}"/></p>
</div><p>To reduce a ternary condition by one step:</p>
<ol class="arabic">
<li><p class="first">If its first operand can be reduced, reduce it</p>
</li>
<li><p class="first">Else if its first operand is <code class="docutils literal notranslate"><span class="pre">true</span></code></p>
<blockquote>
<div><ol class="arabic simple">
<li>Push <code class="docutils literal notranslate"><span class="pre">true</span></code> and the corresponding divergence point identifier on the divergence stack.</li>
<li>Replace the whole operation by its second operand wrapped in a <code class="docutils literal notranslate"><span class="pre">JoinExpr</span></code> construct</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else</p>
<blockquote>
<div><ol class="arabic simple">
<li>ASSERT(its first operand is <code class="docutils literal notranslate"><span class="pre">false</span></code>)</li>
<li>Push <code class="docutils literal notranslate"><span class="pre">false</span></code> and the corresponding divergence point identifier on the divergence stack.</li>
<li>Replace the whole operation by its third operand wrapped in a <code class="docutils literal notranslate"><span class="pre">JoinExpr</span></code> construct.</li>
</ol>
</div></blockquote>
</li>
</ol>
<div class="math">
<p><img src="images/math/9eed636bcf178d97d1deef6ac8635c89f5b70c79.png" alt="\begin{align*}
    \ottdruleternaryXXreduce{}\\
    \ottdruleternaryXXtrue{}\\
    \ottdruleternaryXXfalse{}
\end{align*}"/></p>
</div><p>To reduce a <code class="docutils literal notranslate"><span class="pre">JoinExpr</span></code> by one step:</p>
<ol class="arabic simple">
<li>If its operand is not a lvalue, and can be reduced, then reduce it by one step</li>
<li>Else:<ol class="arabic">
<li>ASSERT(the divergence stack is not empty)</li>
<li>Pop the last element from the divergence stack</li>
<li>Replace the whole expression by its operand</li>
</ol>
</li>
</ol>
<div class="math">
<p><img src="images/math/8165a62e2f4e98de35fa134a9e7bf624ade3f4d3.png" alt="\begin{align*}
    \ottdrulejoinXXexprXXelim{}\\
    \ottdrulejoinXXexprXXreduce{}
\end{align*}"/></p>
</div></div>
<div class="section" id="variables">
<h4>Variables<a class="headerlink" href="#variables" title="Permalink to this headline">¶</a></h4>
<p>A variable name can be reduced in one step into whatever that name binds in the current environment.
This does not require any memory access: it is purely used to represent scoping, and most names just bind to lvalues.</p>
<p>To reduce a (valid) lvalue:</p>
<ol class="arabic simple">
<li>Emit a load to the corresponding address, of a size appropriate for the type of the value</li>
<li>If the type of the expression was an enum type, and the value loaded is not a valid value of that type, replace it by an unspecified valid value of that type</li>
<li>Replace the whole expression by this value</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The 2nd step is to prevent races from allowing the creation of invalid enum values, which could cause problems to switches without default cases.
We don’t need a similar rules for pointers or array references, because we do not allow potentially racy assignments to variables of these types.</p>
</div>
<p>To reduce an invalid left-value, any of the following is acceptable:</p>
<ul class="simple">
<li>Trap</li>
<li>Replace it by the default value of that type.</li>
</ul>
<div class="admonition-todo admonition" id="index-3">
<p class="first admonition-title">Todo</p>
<p class="last">We should extend this possible behavior to also accept (0,0,0,X) for some specific values of X for “vector reads” to match <a class="reference external" href="https://github.com/gpuweb/spirv-execution-env/blob/master/execution-env.md">https://github.com/gpuweb/spirv-execution-env/blob/master/execution-env.md</a>
I just have to figure out what exactly these vector reads map to in WHLSL.
<a class="reference external" href="https://github.com/gpuweb/WHLSL/issues/316">https://github.com/gpuweb/WHLSL/issues/316</a></p>
</div>
</div>
<div class="section" id="reduction-to-an-abstract-left-value">
<span id="reduction-abstract-left-value-label"></span><h4>Reduction to an abstract left-value<a class="headerlink" href="#reduction-to-an-abstract-left-value" title="Permalink to this headline">¶</a></h4>
<div class="admonition-todo admonition" id="index-4">
<p class="first admonition-title">Todo</p>
<p class="last">my naming here is utterly terrible, I really should find better names for these things.</p>
</div>
<p>We now define a notion of “reducing <code class="docutils literal notranslate"><span class="pre">e</span></code> one step to an abstract left-value”. This will be used to define how much to reduce things on the left-side of assignments.
For example, in “x = y”, we do not want to reduce “x” all the way to a load, although we do want to reduce “y” to a load. Here is the definition:</p>
<ol class="arabic">
<li><p class="first">If <code class="docutils literal notranslate"><span class="pre">e</span></code> is of the form <code class="docutils literal notranslate"><span class="pre">e1.foo</span></code></p>
<blockquote>
<div><ol class="arabic simple">
<li>If <code class="docutils literal notranslate"><span class="pre">e1</span></code> can be reduced one step to an abstract left-value, do it</li>
<li>Else if <code class="docutils literal notranslate"><span class="pre">e</span></code> had a left-value type and <code class="docutils literal notranslate"><span class="pre">e1</span></code> is a left value (valid or not), replace the whole expression by <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">operator&amp;.foo(&amp;e1)</span></code>, using the instance of <code class="docutils literal notranslate"><span class="pre">operator&amp;.foo</span></code> that was used to give a left-value type to <code class="docutils literal notranslate"><span class="pre">e</span></code>.</li>
<li>Else fail</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else if <code class="docutils literal notranslate"><span class="pre">e</span></code> is of the form <code class="docutils literal notranslate"><span class="pre">e1[e2]</span></code></p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">If <code class="docutils literal notranslate"><span class="pre">e1</span></code> can be reduced one step to an abstract left-value, do it</p>
</li>
<li><p class="first">Else if <code class="docutils literal notranslate"><span class="pre">e1</span></code> had an array reference type and can be reduced one step (normally), do it</p>
</li>
<li><p class="first">Else if <code class="docutils literal notranslate"><span class="pre">e2</span></code> can be reduced one step (normally), do it</p>
</li>
<li><p class="first">Else if <code class="docutils literal notranslate"><span class="pre">e1</span></code> is <code class="docutils literal notranslate"><span class="pre">null</span></code>, replace the whole expression by an invalid left-value.</p>
</li>
<li><p class="first">Else if <code class="docutils literal notranslate"><span class="pre">e1</span></code> is an array reference:</p>
<blockquote>
<div><ol class="arabic simple">
<li>ASSERT(<code class="docutils literal notranslate"><span class="pre">e2</span></code> is an integer)</li>
<li>If <code class="docutils literal notranslate"><span class="pre">e2</span></code> is out of the bounds of <code class="docutils literal notranslate"><span class="pre">e1</span></code>, either replace the whole expression by an invalid left-value, or replace <code class="docutils literal notranslate"><span class="pre">e2</span></code> by an unspecified in-bounds value.</li>
<li>Else replace the whole expression by a left-value, to an address computed by adding the address in <code class="docutils literal notranslate"><span class="pre">e1</span></code> to the product of <code class="docutils literal notranslate"><span class="pre">e2</span></code> and the stride computed from the type of <code class="docutils literal notranslate"><span class="pre">e1</span></code>’s elements.</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else if <code class="docutils literal notranslate"><span class="pre">e</span></code> had a left-value type and <code class="docutils literal notranslate"><span class="pre">e1</span></code> is a left value (valid or not), replace the whole expression by <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">operator&amp;[](&amp;e1,</span> <span class="pre">e2)</span></code> using the instance of <code class="docutils literal notranslate"><span class="pre">operator&amp;[]</span></code> that was used to give a left-value type to <code class="docutils literal notranslate"><span class="pre">e</span></code>.</p>
</li>
<li><p class="first">Else fail</p>
</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else if <code class="docutils literal notranslate"><span class="pre">e</span></code> is not a lValue (valid or not)</p>
<blockquote>
<div><ol class="arabic simple">
<li>ASSERT(<code class="docutils literal notranslate"><span class="pre">e</span></code> can be reduced)</li>
<li>Reduce <code class="docutils literal notranslate"><span class="pre">e</span></code></li>
</ol>
</div></blockquote>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">in the rules we say “e is an abstract left-value” as a short hand for “e cannot be reduced further to an abstract left value”</p>
</div>
<div class="math">
<p><img src="images/math/bc50368984d799eea039fa96f0064796a9c32894.png" alt="\begin{align*}
    \ottdrulealvalXXdotXXreduce{}\\
    \ottdrulealvalXXdotXXander{}\\
    \ottdrulealvalXXarrayXXreduceXXleft{}\\
    \ottdrulealvalXXarrayXXrefXXreduce{}\\
    \ottdrulealvalXXarrayXXreduceXXright{}\\
    \ottdrulearrayXXnullXXaccess{}\\
    \ottdrulearrayXXrefXXinvalid{}\\
    \ottdrulearrayXXrefXXclamped{}\\
    \ottdrulearrayXXrefXXvalid{}\\
    \ottdrulealvalXXarrayXXander{}\\
    \ottdrulealvalXXgenericXXreduce{}
\end{align*}"/></p>
</div></div>
<div class="section" id="assignment">
<span id="assignment-exec-label"></span><h4>Assignment<a class="headerlink" href="#assignment" title="Permalink to this headline">¶</a></h4>
<p>To reduce an assignment <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">=</span> <span class="pre">e2</span></code>:</p>
<ol class="arabic">
<li><p class="first">If <code class="docutils literal notranslate"><span class="pre">e1</span></code> can be reduced to an abstract left-value, do it</p>
</li>
<li><p class="first">Else if <code class="docutils literal notranslate"><span class="pre">e2</span></code> can be reduced, reduce it.</p>
</li>
<li><p class="first">Else if <code class="docutils literal notranslate"><span class="pre">e1</span></code> is a valid lvalue</p>
<blockquote>
<div><ol class="arabic simple">
<li>Emit a store to the address of the lvalue, of the value on the right of the equal, of a size appropriate for the type of that value</li>
<li>Replace the entire expression by the value on the right of the equal.</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else if <code class="docutils literal notranslate"><span class="pre">e1</span></code> is an invalid lvalue, either replace the whole expression by <code class="docutils literal notranslate"><span class="pre">e2</span></code> or trap</p>
</li>
<li><p class="first">Else if <code class="docutils literal notranslate"><span class="pre">e1</span></code> is of the form <code class="docutils literal notranslate"><span class="pre">e3.foo</span></code></p>
<blockquote>
<div><ol class="arabic simple">
<li>ASSERT(<code class="docutils literal notranslate"><span class="pre">e1</span></code> had an abstract left-value type)</li>
<li>Replace the whole expression by an assignment to <code class="docutils literal notranslate"><span class="pre">e3</span></code> of the result of a call to <code class="docutils literal notranslate"><span class="pre">operator.foo=</span></code> with the arguments <code class="docutils literal notranslate"><span class="pre">e3</span></code> and <code class="docutils literal notranslate"><span class="pre">e2</span></code>, using the instance of <code class="docutils literal notranslate"><span class="pre">operator.foo=</span></code> that was used to give an abstract left-value type to <code class="docutils literal notranslate"><span class="pre">e1</span></code>.</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Else</p>
<blockquote>
<div><ol class="arabic simple">
<li>ASSERT(<code class="docutils literal notranslate"><span class="pre">e1</span></code> is of the form <code class="docutils literal notranslate"><span class="pre">e3[e4]</span></code>)</li>
<li>ASSERT(<code class="docutils literal notranslate"><span class="pre">e1</span></code> had an abstract left-value type)</li>
<li>Replace the whole expression by an assignment to <code class="docutils literal notranslate"><span class="pre">e3</span></code> of the result of a call to <code class="docutils literal notranslate"><span class="pre">operator[]=</span></code> with the arguments <code class="docutils literal notranslate"><span class="pre">e3</span></code>, <code class="docutils literal notranslate"><span class="pre">e4</span></code>, and <code class="docutils literal notranslate"><span class="pre">e2</span></code>, using the instance of <code class="docutils literal notranslate"><span class="pre">operator[]=</span></code> that was used to give an abstract left-value type to <code class="docutils literal notranslate"><span class="pre">e1</span></code>.</li>
</ol>
</div></blockquote>
</li>
</ol>
<div class="math">
<p><img src="images/math/e6466bbd4a7f5ab916d9416c189143cf99dba7ae.png" alt="\begin{align*}
    \ottdruleassignXXleftXXreduce{}\\
    \ottdruleassignXXrightXXreduce{}\\
    \ottdruleassignXXexecute{}\\
    \ottdruleassignXXinvalidXXignore{}\\
    \ottdruleassignXXinvalidXXtrap{}\\
    \ottdruleassignXXsetter{}\\
    \ottdruleassignXXindexedXXsetter{}
\end{align*}"/></p>
</div></div>
<div class="section" id="pointers-and-references">
<h4>Pointers and references<a class="headerlink" href="#pointers-and-references" title="Permalink to this headline">¶</a></h4>
<p>WHLSL has both pointers and array references. Pointers let the programmer access a specific memory location, but do not allow any pointer arithmetic.
Array references are actually bounds-checked fat-pointers.</p>
<p>The <code class="docutils literal notranslate"><span class="pre">&amp;</span></code> and <code class="docutils literal notranslate"><span class="pre">*</span></code> operators simply convert between left-values and pointers.
To reduce <code class="docutils literal notranslate"><span class="pre">&amp;</span> <span class="pre">e</span></code>:</p>
<ol class="arabic simple">
<li>If <code class="docutils literal notranslate"><span class="pre">e</span></code> can be reduced to an abstract left-value, do it</li>
<li>Else if <code class="docutils literal notranslate"><span class="pre">e</span></code> is an invalid lvalue, either replace the whole expression with null, or trap</li>
<li>Else ASSERT(<code class="docutils literal notranslate"><span class="pre">e</span></code> is a valid lvalue), and replace the whole expression by a pointer to the same address</li>
</ol>
<p>To reduce <code class="docutils literal notranslate"><span class="pre">*</span> <span class="pre">e</span></code>:</p>
<ol class="arabic simple">
<li>If <code class="docutils literal notranslate"><span class="pre">e</span></code> is null, either trap or replace the whole expression by an invalid left-value</li>
<li>Else if <code class="docutils literal notranslate"><span class="pre">e</span></code> is a pointer, replace the whole expression by a lvalue to the same address in the same address-space</li>
<li>Else reduce <code class="docutils literal notranslate"><span class="pre">e</span></code></li>
</ol>
<div class="math">
<p><img src="images/math/5752416c1dbf24a46efdae1262a31c41f3bed780.png" alt="\begin{align*}
    \ottdruletakeXXptrXXreduce{}\\
    \ottdruletakeXXptrXXinvalidXXnull{}\\
    \ottdruletakeXXptrXXinvalidXXtrap{}\\
    \ottdruletakeXXptrXXlval{}\\
    \ottdrulederefXXnullXXtrap{}\\
    \ottdrulederefXXnullXXinvalid{}\\
    \ottdrulederefXXptr{}\\
    \ottdrulederefXXreduce{}
\end{align*}"/></p>
</div></div>
<div class="section" id="arrays">
<h4>Arrays<a class="headerlink" href="#arrays" title="Permalink to this headline">¶</a></h4>
<p>The <code class="docutils literal notranslate"><span class="pre">&#64;</span></code> operator is used to turn a lvalue into an array reference, using the size information computed during typing to set the bounds.
More precisely, to reduce <code class="docutils literal notranslate"><span class="pre">&#64;</span> <span class="pre">e</span></code>:</p>
<ol class="arabic simple">
<li>If <code class="docutils literal notranslate"><span class="pre">e</span></code> is an LValue and was of type LValue of an array of size <code class="docutils literal notranslate"><span class="pre">n</span></code> during typing, replace it by an array reference to the same address, same address space, and with a bound of <code class="docutils literal notranslate"><span class="pre">n</span></code></li>
<li>Else if it is an LValue and was of type LValue of a non-array type during typing, replace it by an array reference to the same address, same address space, and with a bound of <code class="docutils literal notranslate"><span class="pre">1</span></code></li>
<li>Else if it is an invalid lvalue, either replace the whole expression by null, or trap</li>
<li>Else reduce it</li>
</ol>
<div class="math">
<p><img src="images/math/34e69f19205a8bacda598d196f1189884e37d7f7.png" alt="\begin{align*}
    \ottdrulemakeXXrefXXlval{}\\
    \ottdrulemakeXXrefXXinvalidXXnull{}\\
    \ottdrulemakeXXrefXXinvalidXXtrap{}\\
    \ottdrulemakeXXrefXXreduce{}
\end{align*}"/></p>
</div><p>There is no explicit dereferencing operator for array references: they can just be used with the array syntax.
The <code class="docutils literal notranslate"><span class="pre">[]</span></code> dereferencing operator is polymorphic: its first operand can be either an array reference, or a value for which the relevant operators (<code class="docutils literal notranslate"><span class="pre">operator&amp;[]</span></code>, <code class="docutils literal notranslate"><span class="pre">operator[]=</span></code>, or <code class="docutils literal notranslate"><span class="pre">operator[]</span></code>) are defined.
To reduce <code class="docutils literal notranslate"><span class="pre">e1[e2]</span></code> by one step:</p>
<ol class="arabic simple">
<li>If the whole expression can be reduced to an abstract left-value, do it</li>
<li>Else replace the whole expression by <code class="docutils literal notranslate"><span class="pre">operator[](e1,</span> <span class="pre">e2)</span></code>, using the instance of <code class="docutils literal notranslate"><span class="pre">operator[]</span></code> that was used during the typing of this array dereference.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the case where <code class="docutils literal notranslate"><span class="pre">operator&amp;[]</span></code> can be used, it will be used through the rules for reduction to an abstract left-value (see <a class="reference internal" href="#reduction-abstract-left-value-label"><span class="std std-ref">Reduction to an abstract left-value</span></a>). For <code class="docutils literal notranslate"><span class="pre">operator[]=</span></code>, see the section on assignment (<a class="reference internal" href="#assignment-exec-label"><span class="std std-ref">Assignment</span></a>).</p>
</div>
<div class="math">
<p><img src="images/math/d87e910dbef668fe638e391447655075d9cb7cb8.png" alt="\begin{align*}
    \ottdrulearrayXXderefXXreduce{}\\
    \ottdrulearrayXXderefXXgetter{}
\end{align*}"/></p>
</div></div>
<div class="section" id="dot-operator">
<h4>Dot operator<a class="headerlink" href="#dot-operator" title="Permalink to this headline">¶</a></h4>
<p>The dot operator is used for two purposes: accessing the fields of structs (or custom <code class="docutils literal notranslate"><span class="pre">operator&amp;.foo</span></code>, <code class="docutils literal notranslate"><span class="pre">operator.foo=</span></code>, <code class="docutils literal notranslate"><span class="pre">operator.foo</span></code>), and getting an element of an enum.
Since we already eliminated the case where it is used to get an element of an enum (see <a class="reference internal" href="#typing-expressions-label"><span class="std std-ref">Typing expressions</span></a>), we only have to deal with the getters/setters/address-takers.
Additionally, it can be overloaded (through <code class="docutils literal notranslate"><span class="pre">operator&amp;.foo</span></code>, <code class="docutils literal notranslate"><span class="pre">operator.foo=</span></code> and <code class="docutils literal notranslate"><span class="pre">operator.foo</span></code>).
To reduce <code class="docutils literal notranslate"><span class="pre">e.foo</span></code> for some identifier <code class="docutils literal notranslate"><span class="pre">foo</span></code>:</p>
<ol class="arabic simple">
<li>If the whole expression can be reduced to an abstract left-value, do it</li>
<li>Else replace the whole expression by <code class="docutils literal notranslate"><span class="pre">operator.foo(e1)</span></code>, using the instance of <code class="docutils literal notranslate"><span class="pre">operator.foo</span></code> that was used during the typing of this dot operator.</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the case where <code class="docutils literal notranslate"><span class="pre">operator&amp;.foo</span></code> can be used, it will be used through the rules for reduction to an abstract left-value (see <a class="reference internal" href="#reduction-abstract-left-value-label"><span class="std std-ref">Reduction to an abstract left-value</span></a>). For <code class="docutils literal notranslate"><span class="pre">operator.foo=</span></code>, see the section on assignment (<a class="reference internal" href="#assignment-exec-label"><span class="std std-ref">Assignment</span></a>).</p>
</div>
<div class="math">
<p><img src="images/math/94019cdb99cb91cad97539b69abb32b743ddc46b.png" alt="\begin{align*}
    \ottdruledotXXreduce{}\\
    \ottdruledotXXgetter{}
\end{align*}"/></p>
</div></div>
<div class="section" id="read-modify-write-expressions">
<h4>Read-modify-write expressions<a class="headerlink" href="#read-modify-write-expressions" title="Permalink to this headline">¶</a></h4>
<p>To reduce an expression <code class="docutils literal notranslate"><span class="pre">e++</span></code> or <code class="docutils literal notranslate"><span class="pre">e--</span></code>:</p>
<ol class="arabic">
<li><p class="first">If <code class="docutils literal notranslate"><span class="pre">e</span></code> can be reduced to an abstract left value, do it</p>
</li>
<li><p class="first">Else:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Let <code class="docutils literal notranslate"><span class="pre">addr</span></code> be a fresh address</li>
<li>Replace the whole expression by <code class="docutils literal notranslate"><span class="pre">LVal(addr)</span> <span class="pre">=</span> <span class="pre">e,</span> <span class="pre">e</span> <span class="pre">=</span> <span class="pre">LVal(addr)</span> <span class="pre">+</span> <span class="pre">1,</span> <span class="pre">LVal(addr)</span></code> (replacing the <code class="docutils literal notranslate"><span class="pre">+</span></code> by <code class="docutils literal notranslate"><span class="pre">-</span></code> for <code class="docutils literal notranslate"><span class="pre">e--</span></code>)</li>
</ol>
</div></blockquote>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">depending on <code class="docutils literal notranslate"><span class="pre">e</span></code>, this can lead to calls to getters/setters or address takers.</p>
</div>
<div class="math">
<p><img src="images/math/4e70021f01e337f14f22f30a27ab76b219ad74df.png" alt="\begin{align*}
    \ottdrulepostfixXXincrXXreduce{}\\
    \ottdrulepostfixXXincrXXelim{}
\end{align*}"/></p>
</div><p>To reduce an expression <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">+=</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">-=</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">*=</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">/=</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">%=</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">^=</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">&amp;=</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">|=</span> <span class="pre">e2</span></code>, <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">&gt;&gt;=</span> <span class="pre">e2</span></code>, or <code class="docutils literal notranslate"><span class="pre">e1</span> <span class="pre">&lt;&lt;=</span> <span class="pre">e2</span></code>:</p>
<ol class="arabic simple">
<li>If <code class="docutils literal notranslate"><span class="pre">e1</span></code> can be reduced to an abstract left-value, do it</li>
<li>Else replace the whole expression by an assignment to <code class="docutils literal notranslate"><span class="pre">e1</span></code> of the result of the corresponding operator, called on <code class="docutils literal notranslate"><span class="pre">e1</span></code> and <code class="docutils literal notranslate"><span class="pre">e2</span></code></li>
</ol>
<div class="math">
<p><img src="images/math/859063942575f639744349f4b8fb3f0ad6ce9301.png" alt="\begin{align*}
    \ottdruleplusXXequalXXreduce{}\\
    \ottdruleplusXXequalXXelim{}
\end{align*}"/></p>
</div></div>
<div class="section" id="calls">
<h4>Calls<a class="headerlink" href="#calls" title="Permalink to this headline">¶</a></h4>
<p>Overloaded function calls have already been resolved to point to a specific function declaration during the validation phase.</p>
<p>Like we added <code class="docutils literal notranslate"><span class="pre">Loop</span></code> or <code class="docutils literal notranslate"><span class="pre">JoinExpr</span></code>, we add a special construct <code class="docutils literal notranslate"><span class="pre">Call</span></code> that takes as argument a statement and return an expression.
Informally, it is a way to transform a return statement into the corresponding value.</p>
<p>To reduce a function call by one step:</p>
<ol class="arabic">
<li><p class="first">If there is at least an argument that can be reduced, reduce the left-most argument that can be reduced.</p>
</li>
<li><p class="first">Else:</p>
<blockquote>
<div><ol class="arabic">
<li><p class="first">ASSERT(the number of arguments and parameters to the function match)</p>
</li>
<li><p class="first">Create a new environment from the current environment</p>
</li>
<li><p class="first">For each parameter of the function, from left to right:</p>
<blockquote>
<div><ol class="arabic simple">
<li>Lookup the address of that parameter</li>
<li>Emit a store of the value of the corresponding argument to that address, of a size appropriate to the type of it. That store is po-after any other store emitted by this step for previous parameters.</li>
<li>Modify the new environment to have a binding from that parameter name to that address</li>
</ol>
</div></blockquote>
</li>
<li><p class="first">Make a block statement from the body of the function, annotated with this new environment</p>
</li>
<li><p class="first">Wrap that block in the <code class="docutils literal notranslate"><span class="pre">Call</span></code> construct</p>
</li>
<li><p class="first">Replace the entire expression by that construct.</p>
</li>
</ol>
</div></blockquote>
</li>
</ol>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Contrary to C/C++, execution order is fully specified: it is always left-to-right.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The new environment binds the parameter names to the argument values, regardless of whether there was already a binding for that name.
This allows shadowing global variables.</p>
</div>
<div class="math">
<p><img src="images/math/ddffb878bba26429f744720f8a81effcc96942fb.png" alt="\begin{align*}
    \ottdrulecallXXreduce{}\\
    \ottdrulecallXXresolve{}
\end{align*}"/></p>
</div><p>To reduce a <code class="docutils literal notranslate"><span class="pre">Call</span></code> construct by one step:</p>
<ol class="arabic simple">
<li>If its argument can be reduced, reduce it</li>
<li>Else if its argument is <code class="docutils literal notranslate"><span class="pre">return;</span></code> or an empty block, replace it by a special <code class="docutils literal notranslate"><span class="pre">Void</span></code> value. Nothing can be done with such a value, except discarding it (see Effectful Expression).</li>
<li>Else if its argument is <code class="docutils literal notranslate"><span class="pre">return</span> <span class="pre">val;</span></code> for some value <code class="docutils literal notranslate"><span class="pre">val</span></code>, then replace it by this value.</li>
</ol>
<div class="math">
<p><img src="images/math/864fa9b4023cd0c68d30883773329aed79ef3e4a.png" alt="\begin{align*}
    \ottdrulecallXXconstructXXreduce{}\\
    \ottdrulecallXXreturnXXvoid{}\\
    \ottdrulecallXXendXXfunction{}\\
    \ottdrulecallXXreturn{}
\end{align*}"/></p>
</div></div>
<div class="section" id="id1">
<h4>Other<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h4>
<p>Parentheses have no effect at runtime (beyond their effect during parsing).</p>
<p>The comma operator simply reduces its first operand as long as it can, then drops it and is replaced by its second operand.</p>
<div class="math">
<p><img src="images/math/0d09544bfe5e907b8294a53b8875b48cd712c82a.png" alt="\begin{align*}
    \ottdrulecommaXXreduce{}\\
    \ottdrulecommaXXnext{}\\
    \ottdruleparensXXexec{}
\end{align*}"/></p>
</div></div>
</div>
<div class="section" id="generated-functions">
<h3>Generated functions<a class="headerlink" href="#generated-functions" title="Permalink to this headline">¶</a></h3>
<p>We saw in the validation section that many functions can be automatically generated:</p>
<ul class="simple">
<li>address-takers for each field of each struct</li>
<li>indexed address-takers for each array type</li>
<li>(indexed) getters and setters for each (indexed) address-taker in the thread address space</li>
</ul>
<p>In this section we will describe how they behave at runtime.</p>
<p>For each field <code class="docutils literal notranslate"><span class="pre">foo</span></code> with type <code class="docutils literal notranslate"><span class="pre">T</span></code> of a struct <code class="docutils literal notranslate"><span class="pre">Bar</span></code>, 4 address-takers are generated, one for each address-space.
Each of them return a pointer to an address that is the sum of the address of their parameter and the offset required to hit the corresponding field.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We describe these functions in this way, because they are not writable directly in the language.</p>
</div>
<p>For each type of the form <code class="docutils literal notranslate"><span class="pre">T[n]</span></code> which is used in the program, the following declarations are generated:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>thread T* operator&amp;[](thread T[n]* a, uint32 i) { return &amp;((@a)[i]); }
threadgroup T* operator&amp;[](threadgroup T[n]* a, uint32 i) { return &amp;((@a)[i]); }
device T* operator&amp;[](device T[n]* a, uint32 i) { return &amp;((@a)[i]); }
constant T* operator&amp;[](constant T[n]* a, uint32 i) { return &amp;((@a)[i]); }
</pre></div>
</div>
<p>For each declaration of the form <code class="docutils literal notranslate"><span class="pre">address-space</span> <span class="pre">T*</span> <span class="pre">operator&amp;.foo(thread</span> <span class="pre">Bar*</span> <span class="pre">b)</span></code> for some <code class="docutils literal notranslate"><span class="pre">address-space</span></code>, the following declarations are generated:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>T operator.foo(Bar b) { return b.foo; }
Bar operator.foo=(Bar b, T newval) { b.foo = newval; return b; }
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The <code class="docutils literal notranslate"><span class="pre">b.foo</span></code> part in both of the above uses the address-taker, as <code class="docutils literal notranslate"><span class="pre">b</span></code> is a function parameter and thus a left value</p>
</div>
<p>For each declaration of the form <code class="docutils literal notranslate"><span class="pre">address-space</span> <span class="pre">T2*</span> <span class="pre">operator&amp;[](thread</span> <span class="pre">T1*</span> <span class="pre">a,</span> <span class="pre">uint32</span> <span class="pre">i)</span></code> for some <code class="docutils literal notranslate"><span class="pre">address-space</span></code>, the following declarations are generated:</p>
<div class="highlight-none notranslate"><div class="highlight"><pre><span></span>T2 operator[](T1 a, uint32 i) { return a[i]; }
T1 operator[]=(T1 a, uint32 i, T2 newval) { a[i] = newval; return a; }
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Similarily, <code class="docutils literal notranslate"><span class="pre">a[i]</span></code> in both of the above use the indexed address-taker, as <code class="docutils literal notranslate"><span class="pre">a</span></code> is a function parameter, and thus a left-value.
Such generated getters and setters may look useless, but they are used when something is not a left-value, for example because of nested calls to getters/setters.
For example you could have a struct Foo, with a getter for the field bar, returning a struct Bar, with an ander for the field baz.
When using foo.bar.baz, it is not possible to use the ander for Bar, as foo.bar is not a left-value. So we instead use the generated getter (that behind the scene copies foo.bar into its parameter, and then uses the ander).</p>
</div>
</div>
<div class="section" id="memory-model">
<h3>Memory model<a class="headerlink" href="#memory-model" title="Permalink to this headline">¶</a></h3>
<p>Our memory model is strongly inspired by the Vulkan memory model, as presented in <a class="reference external" href="https://github.com/KhronosGroup/Vulkan-MemoryModel/blob/master/alloy/spirv.als">https://github.com/KhronosGroup/Vulkan-MemoryModel/blob/master/alloy/spirv.als</a> as of the git commit f9110270e1799041bdaaf00a1db70fd4175d433f
and in <a class="reference external" href="https://github.com/KhronosGroup/Vulkan-Docs/blob/master/appendices/memorymodel.txt">https://github.com/KhronosGroup/Vulkan-Docs/blob/master/appendices/memorymodel.txt</a> as of the git commit 56e0289318a4cd23aa5f5dcfb290ee873be53b82.
That memory model is under Creative Commons Attribution 4.0 International License per the comment at the top of both files: <a class="reference external" href="http://creativecommons.org/licenses/by/4.0/">http://creativecommons.org/licenses/by/4.0/</a> and is Copyright (c) 2017-2018 Khronos Group or Copyright (c) 2017-2019 Khronos Group depending on the file.</p>
<p>The main difference between the two models is that we avoid undefined behaviour by making races merely make reads return unspecified results.
This is in turn safe, as our execution semantics for loads (see above) clamp any enum value to a valid value of that type, and there can be no race on pointers or array references as they are limited to the <code class="docutils literal notranslate"><span class="pre">thread</span></code> address space.</p>
<p>Apart from that, we only removed parts of the model, since some operations supported by Vulkhan are not supported by WHLSL, and renamed some elements for consistency with the rest of this specification.</p>
<div class="section" id="memory-locations">
<h4>Memory locations<a class="headerlink" href="#memory-locations" title="Permalink to this headline">¶</a></h4>
<p>A memory location identifies unique storage for 8 bits of data.
Memory operations access a set of memory locations consisting of one or
more memory locations at a time, e.g. an operation accessing a 32-bit
integer in memory would read/write a set of four memory locations.
Two sets of memory locations overlap if the intersection of their sets of
memory locations is non-empty.
A memory operation must not affect memory at a memory location not within
its set of memory locations.</p>
</div>
<div class="section" id="memory-events-and-program-order">
<h4>Memory events and program order<a class="headerlink" href="#memory-events-and-program-order" title="Permalink to this headline">¶</a></h4>
<p>Some steps in the execution rules provided in the previous section emit memory events.
There are a few possible such events:
- A store of a value to some set of (contiguous) memory locations, that may be atomic
- A load of a value from some set of (contiguous) memory locations, that may be atomic
- A memory barrier (a.k.a. memory fence), that may either ensure synchronization at the threadgroup or whole device scope.
- A control barrier, with a scope that may be threadgroup or device, that may optionally act as a memory barrier at the threadgroup level, or at the device level</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">A write whose value is the same as what was already in those memory locations is still considered to be a write and has all the same effects.</p>
</div>
<div class="admonition-todo admonition" id="index-5">
<p class="first admonition-title">Todo</p>
<p class="last">Add a note here giving an informal mapping of these to Vulkan/MSL/HLSL.</p>
</div>
<p>There is furthermore a total order <code class="docutils literal notranslate"><span class="pre">po</span></code> (program order) on all such events by any given thread. An event is before another by <code class="docutils literal notranslate"><span class="pre">po</span></code> if it is emitted by an
execution rule that is executed by this thread before the rule that emitted the other event. Additionally the store events emitted by the call execution rule
are ordered by <code class="docutils literal notranslate"><span class="pre">po</span></code> in the order of the corresponding parameters (as written in that rule).</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last"><code class="docutils literal notranslate"><span class="pre">po</span></code> is guaranteed to be a total order for a given thread because the call rule is the only one that emits several memory events.</p>
</div>
<div class="admonition-todo admonition" id="index-6">
<p class="first admonition-title">Todo</p>
<p class="last">Rewrite the rest of the model here, translating the kinds of atomics provided; and formalizing what we mean about races.</p>
</div>
</div>
</div>
</div>
<div class="section" id="standard-library">
<span id="standard-library-label"></span><h2>Standard library<a class="headerlink" href="#standard-library" title="Permalink to this headline">¶</a></h2>
<div class="section" id="built-in-types">
<h3>Built-in Types<a class="headerlink" href="#built-in-types" title="Permalink to this headline">¶</a></h3>
<div class="section" id="built-in-scalars">
<h4>Built-in Scalars<a class="headerlink" href="#built-in-scalars" title="Permalink to this headline">¶</a></h4>
<table border="1" class="docutils">
<colgroup>
<col width="6%" />
<col width="46%" />
<col width="48%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Type Name</th>
<th class="head">Description</th>
<th class="head">Representable values</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>void</td>
<td>Must only be used as a return type from functions which don’t return anything.</td>
<td>None</td>
</tr>
<tr class="row-odd"><td>bool</td>
<td>A conditional type.</td>
<td>true or false</td>
</tr>
<tr class="row-even"><td>uint</td>
<td>An unsigned 32-bit integer.</td>
<td>0, 1, 2, … 4294967295</td>
</tr>
<tr class="row-odd"><td>int</td>
<td>A signed 32-bit integer.</td>
<td>-2147483648, -2147483647, … -1, 0, 1, … 2147483647</td>
</tr>
<tr class="row-even"><td>float</td>
<td>An IEEE 32-bit floating-point number.</td>
<td>All values of a IEEE 754 single-precision binary floating-point number</td>
</tr>
</tbody>
</table>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">The following types are not present in WHLSL: dword, min16float, min10float, min16int, min12int, min16uint, string, size_t, ptrdiff_t, double, float64, int64, uint64</p>
</div>
</div>
<div class="section" id="built-in-atomic-types">
<h4>Built-in Atomic Types<a class="headerlink" href="#built-in-atomic-types" title="Permalink to this headline">¶</a></h4>
<ol class="arabic simple">
<li>atomic_int</li>
<li>atomic_uint</li>
</ol>
</div>
<div class="section" id="built-in-aggregate-types">
<h4>Built-in aggregate types<a class="headerlink" href="#built-in-aggregate-types" title="Permalink to this headline">¶</a></h4>
<p>The following are vector types, which list the name of a scalar type and the number of elements in the
vector. Each item below includes two types, which are synonyms for each other.</p>
<ul class="simple">
<li>bool2, or vector&lt;bool, 2&gt;</li>
<li>bool3, or vector&lt;bool, 3&gt;</li>
<li>bool4, or vector&lt;bool, 4&gt;</li>
<li>uint2, or vector&lt;uint, 2&gt;</li>
<li>uint3, or vector&lt;uint, 3&gt;</li>
<li>uint4, or vector&lt;uint, 4&gt;</li>
<li>int2, or vector&lt;int, 2&gt;</li>
<li>int3, or vector&lt;int, 3&gt;</li>
<li>int4, or vector&lt;int, 4&gt;</li>
<li>float2, or vector&lt;float, 2&gt;</li>
<li>float3, or vector&lt;float, 3&gt;</li>
<li>float4, or vector&lt;float, 4&gt;</li>
</ul>
<p>The following are matrix types, which list the name of a scalar type, the number of columns, and the number
of rows, in that order. Each item below includes two types, which are synonyms for each other.</p>
<ul class="simple">
<li>float2x2, or matrix&lt;float, 2, 2&gt;</li>
<li>float2x3, or matrix&lt;float, 2, 3&gt;</li>
<li>float2x4, or matrix&lt;float, 2, 4&gt;</li>
<li>float3x2, or matrix&lt;float, 3, 2&gt;</li>
<li>float3x3, or matrix&lt;float, 3, 3&gt;</li>
<li>float3x4, or matrix&lt;float, 3, 4&gt;</li>
<li>float4x2, or matrix&lt;float, 4, 2&gt;</li>
<li>float4x3, or matrix&lt;float, 4, 3&gt;</li>
<li>float4x4, or matrix&lt;float, 4, 4&gt;</li>
</ul>
<div class="admonition-todo admonition" id="index-7">
<p class="first admonition-title">Todo</p>
<p class="last">Should we have int or bool matrices?</p>
</div>
</div>
<div class="section" id="samplers">
<h4>Samplers<a class="headerlink" href="#samplers" title="Permalink to this headline">¶</a></h4>
<p>Samplers must only be passed into an entry point inside an argument. All samplers are immutable and must be
declared in the “constant” address space. There is no constructor for samplers; it is impossible to create
or destory one in WHLSL. The type is defined as <code class="docutils literal notranslate"><span class="pre">native</span> <span class="pre">typedef</span> <span class="pre">sampler;</span></code>. Samplers are impossible to
introspect. Arrays must not contain samplers anywhere inside them. Functions that return samplers must only
have one return point. Ternary expressions must not return references.</p>
<div class="admonition-todo admonition" id="index-8">
<p class="first admonition-title">Todo</p>
<p class="last">The last sentence does not seem related to samplers. Or should we s/references/samplers/g in it?
<a class="reference external" href="https://github.com/gpuweb/WHLSL/issues/332">https://github.com/gpuweb/WHLSL/issues/332</a></p>
</div>
<div class="admonition-todo admonition" id="index-9">
<p class="first admonition-title">Todo</p>
<p class="last">Robin: I have not put the <code class="docutils literal notranslate"><span class="pre">native</span> <span class="pre">typedef</span></code> syntax in the grammar or the semantics so far, should I?
<a class="reference external" href="https://github.com/gpuweb/WHLSL/issues/332">https://github.com/gpuweb/WHLSL/issues/332</a></p>
</div>
</div>
<div class="section" id="textures">
<h4>Textures<a class="headerlink" href="#textures" title="Permalink to this headline">¶</a></h4>
<p>The following types represent textures:</p>
<ul class="simple">
<li>Texture1D&lt;T&gt;</li>
<li>RWTexture1D&lt;T&gt;</li>
<li>Texture1DArray&lt;T&gt;</li>
<li>RWTexture1DArray&lt;T&gt;</li>
<li>Texture2D&lt;T&gt;</li>
<li>RWTexture2D&lt;T&gt;</li>
<li>Texture2DArray&lt;T&gt;</li>
<li>RWTexture2DArray&lt;T&gt;</li>
<li>Texture3D&lt;T&gt;</li>
<li>RWTexture3D&lt;T&gt;</li>
<li>TextureCube&lt;T&gt;</li>
<li>TextureDepth2D&lt;float&gt;</li>
<li>RWTextureDepth2D&lt;float&gt;</li>
<li>TextureDepth2DArray&lt;float&gt;</li>
<li>RWTextureDepth2DArray&lt;float&gt;</li>
<li>TextureDepthCube&lt;float&gt;</li>
</ul>
<div class="admonition-todo admonition" id="index-10">
<p class="first admonition-title">Todo</p>
<p class="last">Texture2DMS&lt;T&gt;, TextureDepth2DMS&lt;float&gt;
<a class="reference external" href="https://github.com/gpuweb/WHLSL/issues/333">https://github.com/gpuweb/WHLSL/issues/333</a></p>
</div>
<p>Each of the above types accepts a “type argument”. The “T” types above may be any scalar or vector integral or floating point type.</p>
<p>If the type argument, including the <code class="docutils literal notranslate"><span class="pre">&lt;&gt;</span></code> characters is missing, is is assumed to be <code class="docutils literal notranslate"><span class="pre">float4</span></code>.</p>
<p>Textures must only be passed into an entry point inside an argument. Therefore, textures must only be declared
in either the <code class="docutils literal notranslate"><span class="pre">constant</span></code> or <code class="docutils literal notranslate"><span class="pre">device</span></code> address space. A texture declared in the <code class="docutils literal notranslate"><span class="pre">constant</span></code> address space
must never be modified. There is no constructor for textures; it is impossible to create or destroy one in WHLSL.
Arrays must not contain textures anywhere inside them. Functions that return textures must only have one return
point. Ternary expressions must not return references.</p>
<div class="admonition-todo admonition" id="index-11">
<p class="first admonition-title">Todo</p>
<p>“Therefore”: it is not clear to me how it is a consequence (Robin).
“Ternary expressions must not return references”: What kind of references are you referring to? If it is array references, I don’t think it is the right place to mention this (but thank you for the reminder to put it in the validation section).
Similarily, most of these constraints should probably be either duplicated in or moved to the validation section, I will take care of it.</p>
<p class="last">They are not copyable, ie they are references.
<a class="reference external" href="https://github.com/gpuweb/WHLSL/issues/334">https://github.com/gpuweb/WHLSL/issues/334</a></p>
</div>
</div>
</div>
<div class="section" id="built-in-variables">
<h3>Built-in Variables<a class="headerlink" href="#built-in-variables" title="Permalink to this headline">¶</a></h3>
<p>Built-in variables are represented by using semantics. For example, <code class="docutils literal notranslate"><span class="pre">uint</span> <span class="pre">theInstanceID</span> <span class="pre">:</span> <span class="pre">SV_InstanceID</span></code>.
Variables with these semantics must have the type associated with that semantic.</p>
<p>The following built-in variables, as identified by their semantics, are available inside arguments to vertex
shaders:</p>
<table border="1" class="docutils">
<colgroup>
<col width="71%" />
<col width="29%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Semantic Name</th>
<th class="head">Type</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SV_InstanceID</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>SV_VertexID</td>
<td>uint</td>
</tr>
</tbody>
</table>
<p>The following built-in variables, as identified by their semantics, are available inside the return value of
a vertex shader:</p>
<table border="1" class="docutils">
<colgroup>
<col width="65%" />
<col width="35%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Semantic Name</th>
<th class="head">Type</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>PSIZE</td>
<td>float</td>
</tr>
<tr class="row-odd"><td>SV_Position</td>
<td>float4</td>
</tr>
</tbody>
</table>
<p>The following built-in variables, as identified by their semantics, are available inside arguments to fragment
shaders:</p>
<table border="1" class="docutils">
<colgroup>
<col width="69%" />
<col width="31%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Semantic Name</th>
<th class="head">Type</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SV_IsFrontFace</td>
<td>bool</td>
</tr>
<tr class="row-odd"><td>SV_SampleIndex</td>
<td>uint</td>
</tr>
<tr class="row-even"><td>SV_InnerCoverage</td>
<td>uint</td>
</tr>
</tbody>
</table>
<p>The following built-in variables, as identified by their semantics, are available inside the return value of
a fragment shader:</p>
<table border="1" class="docutils">
<colgroup>
<col width="67%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Semantic Name</th>
<th class="head">Type</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SV_Target[n]</td>
<td>float4</td>
</tr>
<tr class="row-odd"><td>SV_Depth</td>
<td>float</td>
</tr>
<tr class="row-even"><td>SV_Coverage</td>
<td>uint</td>
</tr>
</tbody>
</table>
<p>The following built-in variables, as identified by their semantics, are available inside arguments to compute
shaders:</p>
<table border="1" class="docutils">
<colgroup>
<col width="75%" />
<col width="25%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Semantic Name</th>
<th class="head">Type</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>SV_DispatchThreadID</td>
<td>uint3</td>
</tr>
<tr class="row-odd"><td>SV_GroupID</td>
<td>uint3</td>
</tr>
<tr class="row-even"><td>SV_GroupIndex</td>
<td>uint</td>
</tr>
<tr class="row-odd"><td>SV_GroupThreadID</td>
<td>uint3</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="built-in-functions">
<h3>Built-in Functions<a class="headerlink" href="#built-in-functions" title="Permalink to this headline">¶</a></h3>
<div class="admonition-todo admonition" id="index-12">
<p class="first admonition-title">Todo</p>
<p class="last">Fill in this section, including all of the basic arithmetic operators, explaining what behaviors are allowed on overflow.</p>
</div>
<p>Some of these functions only appear in specific shader stages.</p>
<p>We should figure out if atomic handling goes here.</p>
<div class="section" id="integer-arithmetic">
<h4>Integer arithmetic<a class="headerlink" href="#integer-arithmetic" title="Permalink to this headline">¶</a></h4>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Many of the functions described in this section have other overloads for floating point arguments, or for vector/matrix arguments.
These overloads will be described in the corresponding sections.</p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">operator+</span></code>, <code class="docutils literal notranslate"><span class="pre">operator-</span></code> and <code class="docutils literal notranslate"><span class="pre">operator*</span></code> are defined as binary functions on integers, both signed and unsigned.
Their return type is the same as the type of their arguments, and they respectively implement integer addition, substraction and multiplication.
They follow 2-complement semantics in the case of overflow or underflow.
In other terms, they behave as if they computed the result as integers with a large enough width for avoiding both overflow and underflow, then truncated to the 32 low-bits of the result.
<code class="docutils literal notranslate"><span class="pre">mul</span></code> is defined on integers both signed and unsigned as a synonym of operator*.</p>
<p><code class="docutils literal notranslate"><span class="pre">operator-</span></code> is also defined as an unary function on signed integers.
Its return type is also <code class="docutils literal notranslate"><span class="pre">int</span></code>, and it simply returns the negation of its argument.</p>
<p><code class="docutils literal notranslate"><span class="pre">operator++</span></code> and <code class="docutils literal notranslate"><span class="pre">operator--</span></code> are defined as unary functions on integers, both signed and unsigned.
Their return type is the same as the type of their argument.
They return the addition or substraction (respectively) of <code class="docutils literal notranslate"><span class="pre">1</span></code> to their argument, behaving like <code class="docutils literal notranslate"><span class="pre">operator+</span></code> and <code class="docutils literal notranslate"><span class="pre">operator-</span></code> in the case of overflow/underflow.</p>
<div class="admonition-todo admonition" id="index-13">
<p class="first admonition-title">Todo</p>
<p class="last">Decide whether we want to have operator++ at all, or whether it should just be sugar for +1.
We are currently not consistent, not only between spec and implementation, but between sections of this spec.
<a class="reference external" href="https://github.com/gpuweb/WHLSL/issues/336">https://github.com/gpuweb/WHLSL/issues/336</a></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">operator/</span></code> and <code class="docutils literal notranslate"><span class="pre">operator%</span></code> are defined as binary functions on integers, both signed and unsigned.
Their return type is the same as the type of their arguments.
They respectively return the algebraic quotient truncated towards zero (fractional part discarded), and the remainder of the division such that <code class="docutils literal notranslate"><span class="pre">(a/b)*b</span> <span class="pre">+</span> <span class="pre">a%b</span> <span class="pre">==</span> <span class="pre">a</span></code>.
If the second operand is <code class="docutils literal notranslate"><span class="pre">0</span></code>, both return an unspecified value.
If there is an underflow (e.g. from <code class="docutils literal notranslate"><span class="pre">INT_MIN</span> <span class="pre">/</span> <span class="pre">(-1)</span></code>), they follow 2-complement semantics.
In other terms, they behave as if they computed the result as integers with a large enough width for avoiding both overflow and underflow, then truncated to the 32 low-bits of the result.</p>
<p><code class="docutils literal notranslate"><span class="pre">abs</span></code> is defined as an unary function on integers, both signed and unsigned.
Its return type is the same as its argument type.
It returns its argument if it is non-negative, and the opposite of its argument otherwise.
In case of an underflow/overflow it follows 2-complement semantics, so abs(INT_MIN) is INT_MIN.</p>
<p><code class="docutils literal notranslate"><span class="pre">sign</span></code> is defined as an unary function on integers, both signed and unsigned.
Its return type is int.
If its argument is positive, it returns <code class="docutils literal notranslate"><span class="pre">1</span></code>.
If its argument is negative, it returns <code class="docutils literal notranslate"><span class="pre">-1</span></code>.
If its argument is <code class="docutils literal notranslate"><span class="pre">0</span></code>, it returns <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<div class="admonition-todo admonition" id="index-14">
<p class="first admonition-title">Todo</p>
<p class="last">In the current implementation, its return type is always the same as its argument type.
<a class="reference external" href="https://bugs.webkit.org/show_bug.cgi?id=200252">https://bugs.webkit.org/show_bug.cgi?id=200252</a></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">min</span></code> and <code class="docutils literal notranslate"><span class="pre">max</span></code> are defined as binary functions on integers, both signed and unsigned.
Their return type is the same as the type of their arguments.
They return respectively the minimum and the maximum of their arguments.</p>
<p><code class="docutils literal notranslate"><span class="pre">clamp</span></code> is defined as a ternary function on integers, both signed and unsigned.
Its return type is the same as the type of its arguments.
If its third argument is less than its second, it returns an unspecified value.
Otherwise it returns <code class="docutils literal notranslate"><span class="pre">min(max(first,</span> <span class="pre">second),</span> <span class="pre">third)</span></code>.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">We must return an unspecified value in the case where second &gt; third, because it is what SPIR-V (GLSL.std.450 extended instruction set) does.
HLSL does not document that case, but in practice it seems to always return the third.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">In the HLSL documentation, <code class="docutils literal notranslate"><span class="pre">abs</span></code>, <code class="docutils literal notranslate"><span class="pre">sign</span></code>, <code class="docutils literal notranslate"><span class="pre">min</span></code>, <code class="docutils literal notranslate"><span class="pre">max</span></code> and <code class="docutils literal notranslate"><span class="pre">clamp</span></code> are not defined on unsigned integers.
But we found them defined on unsigned integers in the actual implementation, so they are supported in WHLSL on unsigned integers for portability.</p>
</div>
</div>
<div class="section" id="bit-manipulation">
<h4>Bit manipulation<a class="headerlink" href="#bit-manipulation" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">operator&amp;</span></code>, <code class="docutils literal notranslate"><span class="pre">operator|</span></code> and <code class="docutils literal notranslate"><span class="pre">operator^</span></code> are defined as binary functions on booleans, signed integers, and unsigned integers.
Their return type is the same type as their arguments.
They respectively implement bitwise and, or and exclusive or; treating booleans as if they were integers of size 1, with <code class="docutils literal notranslate"><span class="pre">true</span></code> being <code class="docutils literal notranslate"><span class="pre">1</span></code> and <code class="docutils literal notranslate"><span class="pre">false</span></code> being <code class="docutils literal notranslate"><span class="pre">0</span></code>.</p>
<p><code class="docutils literal notranslate"><span class="pre">operator~</span></code> is defined as an unary function on booleans, signed integers, and unsigned integers.
Its return type is the same type as its argument.
It implements bitwise negation on integers, and negation on booleans.</p>
<p><code class="docutils literal notranslate"><span class="pre">operator&lt;&lt;</span></code> and <code class="docutils literal notranslate"><span class="pre">operator&gt;&gt;</span></code> are defined as binary functions, whose first argument can be integers either signed or unsigned, and whose second argument is an unsigned integer.
Their return types are the same type as their first argument.
They respectively shift their first argument left/right by their second argument modulo the bit-width of their first argument.
So for example <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">33</span></code> is the same as <code class="docutils literal notranslate"><span class="pre">x</span> <span class="pre">&lt;&lt;</span> <span class="pre">1</span></code> if x is a 32-bit integer.
In the case of a right shift on an unsigned integer or any left shift, the vacated bits are replaced by 0.
In the case of a right shift on a signed integer, the vacated bits are replaced by the sign bit of the first argument (i.e. it is an arithmetic right-shift, not a logical one).</p>
<p><code class="docutils literal notranslate"><span class="pre">all</span></code> and <code class="docutils literal notranslate"><span class="pre">any</span></code> are defined as unary functions on booleans and integers both signed and unsigned.
Their return type is always <code class="docutils literal notranslate"><span class="pre">bool</span></code>.
They return false on zero and true on any non-zero integer.
They are simply the identity function on booleans.</p>
<p><code class="docutils literal notranslate"><span class="pre">countbits</span></code>, <code class="docutils literal notranslate"><span class="pre">reversebits</span></code>, <code class="docutils literal notranslate"><span class="pre">firstbithigh</span></code> and <code class="docutils literal notranslate"><span class="pre">firstbitlow</span></code> are all unary functions on unsigned integers.
Their return type is also <code class="docutils literal notranslate"><span class="pre">unsigned</span> <span class="pre">int</span></code>.
<code class="docutils literal notranslate"><span class="pre">countbits</span></code> returns the number of bits set to 1 in the binary representation of its argument.
<code class="docutils literal notranslate"><span class="pre">reversebits</span></code> reverses the order of the bits in the binary representation of its argument.
<code class="docutils literal notranslate"><span class="pre">firstbitlow</span></code> returns -1 if its argument is 0, and otherwise returns the index (from the lowest bit being 0 to the highest bit being 31) of the lowest bit set.
<code class="docutils literal notranslate"><span class="pre">firstbithigh</span></code> has four cases:</p>
<ul class="simple">
<li>If its argument is 0, it returns -1 (like <code class="docutils literal notranslate"><span class="pre">firstbitlow</span></code>)</li>
<li>If its argument is -1, it also returns -1</li>
<li>If its argument is positive, it returns the index (from the lowest bit being 0 to the highest bit being 31) of the highest bit set.</li>
<li>If its argument is negative and not -1, it returns the index of the highest bit that is not set.</li>
</ul>
<div class="admonition-todo admonition" id="index-15">
<p class="first admonition-title">Todo</p>
<p class="last">That semantic for firstbithigh is insane, I’d like to get rid of it:
<a class="reference external" href="https://github.com/gpuweb/WHLSL/issues/337">https://github.com/gpuweb/WHLSL/issues/337</a></p>
</div>
</div>
<div class="section" id="floating-point-arithmetic">
<h4>Floating point arithmetic<a class="headerlink" href="#floating-point-arithmetic" title="Permalink to this headline">¶</a></h4>
<p><code class="docutils literal notranslate"><span class="pre">operator+</span></code>, <code class="docutils literal notranslate"><span class="pre">operator-</span></code>, <code class="docutils literal notranslate"><span class="pre">operator*</span></code>, and <code class="docutils literal notranslate"><span class="pre">operator/</span></code> are defined as binary functions on floats.
Their return type is the same as the type of their arguments, and they respectively implement floating-point addition, substraction, multiplication and division
The result of <code class="docutils literal notranslate"><span class="pre">operator/</span></code> is an undefined value if its second argument is either <code class="docutils literal notranslate"><span class="pre">+0.0</span></code> or <code class="docutils literal notranslate"><span class="pre">-0.0</span></code></p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p class="last">Our treatment of division by 0 here is based on the SPIR-V specification for OpFDiv.
MSL instead mandates either NaN or +/-Infinity, following the IEEE-754 standard.</p>
</div>
<div class="admonition-todo admonition" id="index-16">
<p class="first admonition-title">Todo</p>
<p class="last">Decide on what to do about NaN, Inf, Denormals, etc..
See <a class="reference external" href="https://github.com/gpuweb/WHLSL/issues/335">https://github.com/gpuweb/WHLSL/issues/335</a></p>
</div>
<p><code class="docutils literal notranslate"><span class="pre">operator-</span></code> is also defined as an unary function on floats.
Its return type is also <code class="docutils literal notranslate"><span class="pre">float</span></code>, and it simply returns the negation of its argument.</p>
<p>The following functions are all unary functions on floats, and their return type is also float:</p>
<ul class="simple">
<li>cos
Returns the cosine of its argument interpreted as radians
TODO: NaN/+Inf/-Inf</li>
<li>sin
Returns the sine of its argument interpreted as radians
TODO: NaN/+Inf/-Inf</li>
<li>tan
Returns the tangent of its argument interpreted as radians
TODO: NaN/+Inf/-Inf</li>
<li>acos
Returns the arccosine of its argument in radians
In other words, its result is a number in radians whose cosine is its argument.
The range of results is [0 ; Pi], it returns an undefined value if its argument is greater than 1 or smaller than -1.
TODO: verify the range in HLSL + MSL</li>
<li>asin
Returns the arcsine of its argument in radians
In other words its result is a number in radians whose sine is its argument.
The range of results is [-Pi/2 ; Pi/2], it returns an undefined value if its argument is greater than 1 or smaller than -1.
TODO: verify the range in HLSL + MSL</li>
<li>atan
Returns the arctangent of its argument in radians
In other words its result is a number in radians whose tangent is its argument.
The range of results is [-Pi ; Pi].
TODO: verify the range in HLSL + MSL
In C++ it is always in [-Pi/2 ; Pi/2] for example. This makes a lot more sense, because there are two pre-images of any number by tangent in [-Pi/Pi], and we need more information (from atan2) to get the right one.</li>
<li>cosh</li>
<li>sinh</li>
<li>tanh</li>
<li>ceil</li>
<li>floor</li>
<li>round</li>
<li>trunc</li>
<li>exp</li>
<li>exp2</li>
<li>log</li>
<li>log2</li>
<li>log10</li>
<li>sqrt</li>
<li>rsqrt</li>
<li>degrees</li>
<li>radians</li>
<li>saturate</li>
</ul>
<div class="admonition-todo admonition" id="index-17">
<p class="first admonition-title">Todo</p>
<p class="last">I’ve followed the SPIRV-GLSL.std.450 extended instruction set specification here.
I should check what happens to</p>
</div>
<div class="admonition-todo admonition" id="index-18">
<p class="first admonition-title">Todo</p>
<p class="last">ddx, ddy, ddx_fine, ddx_coarse, ddy_fine, ddy_coarse, fwidth</p>
</div>
<p>The following functions are all binary functions on floats, and their return type is also float:</p>
<ul class="simple">
<li>pow</li>
<li>step</li>
<li>ldexp</li>
<li>fmod</li>
<li>atan2</li>
</ul>
<p>The following functions are all ternary functions on floats, and their return type is also float:</p>
<ul class="simple">
<li>smoothstep</li>
<li>lerp</li>
<li>fmod</li>
</ul>
<p>The following functions are all unary functions on floats, and their return type is bool:</p>
<ul class="simple">
<li>isfinite</li>
<li>isinf</li>
<li>isnan</li>
</ul>
<p>Also includes a bunch of special functions like cos, isNaN, …</p>
</div>
<div class="section" id="numerical-compliance">
<h4>Numerical Compliance<a class="headerlink" href="#numerical-compliance" title="Permalink to this headline">¶</a></h4>
<div class="admonition-todo admonition" id="index-19">
<p class="first admonition-title">Todo</p>
<p class="last">Decide on what precision guarantees we can make.
MSL got two different tables, depending on whether it is running in fast-math mode or not.
I did not find the equivalent table for SPIR-V, but it has the nice property of tagging each operation with the different components of fast-math.
We should probably measure how costly forbidding fast-math would be, since NotNaN and NotInf introduce undefined behavior.
<a class="reference external" href="https://github.com/gpuweb/WHLSL/issues/335">https://github.com/gpuweb/WHLSL/issues/335</a></p>
</div>
</div>
<div class="section" id="fences-and-atomic-operations">
<h4>Fences and atomic operations<a class="headerlink" href="#fences-and-atomic-operations" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="cast-operators">
<h4>Cast operators<a class="headerlink" href="#cast-operators" title="Permalink to this headline">¶</a></h4>
<p>Also include the <code class="docutils literal notranslate"><span class="pre">as</span></code> function.</p>
</div>
<div class="section" id="comparison-operators">
<h4>Comparison operators<a class="headerlink" href="#comparison-operators" title="Permalink to this headline">¶</a></h4>
</div>
<div class="section" id="vector-and-matrix-operations">
<h4>Vector and matrix operations<a class="headerlink" href="#vector-and-matrix-operations" title="Permalink to this headline">¶</a></h4>
<p>Includes arithmetic operators (per-element), various swizzles, length, getDimensions, operator[] and operator[]=, determinant</p>
</div>
<div class="section" id="sampler-and-texture-operations">
<h4>Sampler and texture operations<a class="headerlink" href="#sampler-and-texture-operations" title="Permalink to this headline">¶</a></h4>
<p>Sample, Load, Gather, etc..</p>
</div>
</div>
</div>
<div class="section" id="interface-with-javascript">
<h2>Interface with JavaScript<a class="headerlink" href="#interface-with-javascript" title="Permalink to this headline">¶</a></h2>
<p>Shaders are supplied to the Javascript WebGPU API as a single argument
which is understood to be of type ‘DOMString’.</p>
</div>
<div class="section" id="resource-limits">
<h2>Resource Limits<a class="headerlink" href="#resource-limits" title="Permalink to this headline">¶</a></h2>
<ol class="arabic simple">
<li>How many inputs</li>
<li>How many outputs</li>
<li>How many intermediate variables</li>
</ol>
</div>
</div>
<div class="section" id="indices-and-tables">
<h1>Indices and tables<a class="headerlink" href="#indices-and-tables" title="Permalink to this headline">¶</a></h1>
<ul class="simple">
<li><a class="reference internal" href="genindex.html"><span class="std std-ref">Index</span></a></li>
<li><a class="reference internal" href="py-modindex.html"><span class="std std-ref">Module Index</span></a></li>
<li><a class="reference internal" href="search.html"><span class="std std-ref">Search Page</span></a></li>
</ul>
</div>


          </div>
        </div>
      </div>
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
        </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="related" role="navigation" aria-label="related navigation">
      <h3>Navigation</h3>
      <ul>
        <li class="nav-item nav-item-0"><a href="index.html#document-index">WHLSL  documentation</a> &#187;</li> 
      </ul>
    </div>
    <div class="footer" role="contentinfo">
        <a href="http://www.w3.org/Consortium/Legal/ipr-notice#Copyright">Copyright</a> &#169; 2019 the Contributors to the Web High-Level Shading Language Specification, published by the W3C <a href="https://www.w3.org/community/gpu/">GPU for the Web Community Group</a> under the <a href="https://www.w3.org/community/about/agreements/cla/">W3C Community Contributor License Agreement (CLA)</a>. A human-readable <a href="http://www.w3.org/community/about/agreements/cla-deed/">summary</a> is available.
        Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.7.5.
    </div>
  </body>
</html>